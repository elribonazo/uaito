This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: apps/uaito, packages/sdk
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
apps/
  uaito/
    public/
      .well-known/
        apple-developer-merchantid-domain-association
      examples/
        career_coach.html
      next.svg
      vercel.svg
    src/
      actions/
        index.tsx
      ai/
        agents/
          AutomatedEngineer.ts
          Editor.ts
          Execution.ts
          onTool.ts
        prompts/
          AutomatedEngineer.ts
        tools/
          extractWebContent.ts
          tavily.ts
        config.ts
        tools.ts
      app/
        globals.css
        layout.tsx
      components/
        AgentSelector.tsx
        AnimatedGradientText.tsx
        AnimatedText.tsx
        Authenticate.tsx
        Card.tsx
        ClientSideComponents.tsx
        ClientSpaceBackground.tsx
        FeaturedSection.tsx
        Footer.tsx
        IconCard.tsx
        InputComponent.tsx
        KeyFeatures.tsx
        Markdown.tsx
        Messages.tsx
        MobileMenu.tsx
        ParallaxBanner.tsx
        PricingTable.tsx
        Provider.tsx
        Scroll.tsx
        SearchBar.tsx
        SpaceBackground.tsx
        Testimonial.tsx
        TokenCounter.tsx
        ToolComponent.tsx
      core/
        db.ts
        redis.ts
      db/
        models/
          Tool.ts
          Usage.ts
          User.ts
        index.ts
      hooks/
        useThrottle.tsx
      pages/
        api/
          [provider]/
            [agent]/
              messages.ts
          auth/
            [...nextauth].ts
          download/
            [version].ts
          tools/
            [threadId].ts
          key.ts
          webhook.ts
        _app.tsx
        chat.tsx
        dashboard.tsx
        error.tsx
        index.tsx
        preview.tsx
        privacy-policy.tsx
        terms-and-conditions.tsx
        thank-you.tsx
      redux/
        rootReducer.ts
        store.ts
        userSlice.tsx
      utils/
        getSessionUser.ts
      config.ts
    .dockerignore
    .env.release
    .eslintrc.json
    docker-compose.yml
    Dockerfile
    LICENSE
    next-env.d.ts
    next.config.js
    package.json
    postcss.config.js
    README.md
    release
    tailwind.config.js
    tsconfig.json
packages/
  sdk/
    src/
      agents/
        index.ts
      llm/
        huggingface/
          llama/
            constants.ts
          stopCriteria.ts
          types.ts
          utils.ts
        Anthropic.ts
        Base.ts
        HuggingFaceONNX.ts
        Openai.ts
      cli.ts
      config.ts
      index.ts
      types.ts
      utils.ts
    tsup/
      tsup.cjs.ts
      tsup.esm.ts
    build.sh
    package.json
    tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="apps/uaito/public/.well-known/apple-developer-merchantid-domain-association">
7B227073704964223A2239373943394538343346343131343044463144313834343232393232313734313034353044314339464446394437384337313531303944334643463542433731222C2276657273696F6E223A312C22637265617465644F6E223A313731353230333737303832312C227369676E6174757265223A223330383030363039326138363438383666373064303130373032613038303330383030323031303133313064333030623036303936303836343830313635303330343032303133303830303630393261383634383836663730643031303730313030303061303830333038323033653333303832303338386130303330323031303230323038313636333463386230653330353731373330306130363038326138363438636533643034303330323330376133313265333032633036303335353034303330633235343137303730366336353230343137303730366336393633363137343639366636653230343936653734363536373732363137343639366636653230343334313230326432303437333333313236333032343036303335353034306230633164343137303730366336353230343336353732373436393636363936333631373436393666366532303431373537343638366637323639373437393331313333303131303630333535303430613063306134313730373036633635323034393665363332653331306233303039303630333535303430363133303235353533333031653137306433323334333033343332333933313337333433373332333735613137306433323339333033343332333833313337333433373332333635613330356633313235333032333036303335353034303330633163363536333633326437333664373032643632373236663662363537323264373336393637366535663535343333343264353035323466343433313134333031323036303335353034306230633062363934663533323035333739373337343635366437333331313333303131303630333535303430613063306134313730373036633635323034393665363332653331306233303039303630333535303430363133303235353533333035393330313330363037326138363438636533643032303130363038326138363438636533643033303130373033343230303034633231353737656465626436633762323231386636386464373039306131323138646337623062643666326332383364383436303935643934616634613534313162383334323065643831316633343037653833333331663163353463336637656233323230643662616435643465666634393238393839336537633066313361333832303231313330383230323064333030633036303335353164313330313031666630343032333030303330316630363033353531643233303431383330313638303134323366323439633434663933653465663237653663346636323836633366613262626664326534623330343530363038326230363031303530353037303130313034333933303337333033353036303832623036303130353035303733303031383632393638373437343730336132663266366636333733373032653631373037303663363532653633366636643266366636333733373033303334326436313730373036633635363136393633363133333330333233303832303131643036303335353164323030343832303131343330383230313130333038323031306330363039326138363438383666373633363430353031333038316665333038316333303630383262303630313035303530373032303233303831623630633831623335323635366336393631366536333635323036663665323037343638363937333230363336353732373436393636363936333631373436353230363237393230363136653739323037303631373237343739323036313733373337353664363537333230363136333633363537303734363136653633363532303666363632303734363836353230373436383635366532303631373037303663363936333631363236633635323037333734363136653634363137323634323037343635373236643733323036313665363432303633366636653634363937343639366636653733323036663636323037353733363532633230363336353732373436393636363936333631373436353230373036663663363936333739323036313665363432303633363537323734363936363639363336313734363936663665323037303732363136333734363936333635323037333734363137343635366436353665373437333265333033363036303832623036303130353035303730323031313632613638373437343730336132663266373737373737326536313730373036633635326536333666366432663633363537323734363936363639363336313734363536313735373436383666373236393734373932663330333430363033353531643166303432643330326233303239613032376130323538363233363837343734373033613266326636333732366332653631373037303663363532653633366636643266363137303730366336353631363936333631333332653633373236633330316430363033353531643065303431363034313439343537646236666435373438313836383938393736326637653537383530376537396235383234333030653036303335353164306630313031666630343034303330323037383033303066303630393261383634383836663736333634303631643034303230353030333030613036303832613836343863653364303430333032303334393030333034363032323130306336663032336362323631346262333033383838613136323938336531613933663130353666353066613738636462396261346361323431636331346532356530323231303062653363643064666431363234376636343934343735333830653964343463323238613130383930613361316463373234623862346362383838393831386263333038323032656533303832303237356130303330323031303230323038343936643266626633613938646139373330306130363038326138363438636533643034303330323330363733313162333031393036303335353034303330633132343137303730366336353230353236663666373432303433343132303264323034373333333132363330323430363033353530343062306331643431373037303663363532303433363537323734363936363639363336313734363936663665323034313735373436383666373236393734373933313133333031313036303335353034306130633061343137303730366336353230343936653633326533313062333030393036303335353034303631333032353535333330316531373064333133343330333533303336333233333334333633333330356131373064333233393330333533303336333233333334333633333330356133303761333132653330326330363033353530343033306332353431373037303663363532303431373037303663363936333631373436393666366532303439366537343635363737323631373436393666366532303433343132303264323034373333333132363330323430363033353530343062306331643431373037303663363532303433363537323734363936363639363336313734363936663665323034313735373436383666373236393734373933313133333031313036303335353034306130633061343137303730366336353230343936653633326533313062333030393036303335353034303631333032353535333330353933303133303630373261383634386365336430323031303630383261383634386365336430333031303730333432303030346630313731313834313964373634383564353161356532353831303737366538383061326566646537626165346465303864666334623933653133333536643536363562333561653232643039373736306432323465376262613038666437363137636538386362373662623636373062656338653832393834666635343435613338316637333038316634333034363036303832623036303130353035303730313031303433613330333833303336303630383262303630313035303530373330303138363261363837343734373033613266326636663633373337303265363137303730366336353265363336663664326636663633373337303330333432643631373037303663363537323666366637343633363136373333333031643036303335353164306530343136303431343233663234396334346639336534656632376536633466363238366333666132626266643265346233303066303630333535316431333031303166663034303533303033303130316666333031663036303335353164323330343138333031363830313462626230646561313538333338383961613438613939646562656264656261666461636232346162333033373036303335353164316630343330333032653330326361303261613032383836323636383734373437303361326632663633373236633265363137303730366336353265363336663664326636313730373036633635373236663666373436333631363733333265363337323663333030653036303335353164306630313031666630343034303330323031303633303130303630613261383634383836663736333634303630323065303430323035303033303061303630383261383634386365336430343033303230333637303033303634303233303361636637323833353131363939623138366662333563333536636136326266663431376564643930663735346461323865626566313963383135653432623738396638393866373962353939663938643534313064386639646539633266653032333033323264643534343231623061333035373736633564663333383362393036376664313737633263323136643936346663363732363938323132366635346638376137643162393963623962303938393231363130363939306630393932316430303030333138323031383833303832303138343032303130313330383138363330376133313265333032633036303335353034303330633235343137303730366336353230343137303730366336393633363137343639366636653230343936653734363536373732363137343639366636653230343334313230326432303437333333313236333032343036303335353034306230633164343137303730366336353230343336353732373436393636363936333631373436393666366532303431373537343638366637323639373437393331313333303131303630333535303430613063306134313730373036633635323034393665363332653331306233303039303630333535303430363133303235353533303230383136363334633862306533303537313733303062303630393630383634383031363530333034303230316130383139333330313830363039326138363438383666373064303130393033333130623036303932613836343838366637306430313037303133303163303630393261383634383836663730643031303930353331306631373064333233343330333533303338333233313332333933333330356133303238303630393261383634383836663730643031303933343331316233303139333030623036303936303836343830313635303330343032303161313061303630383261383634386365336430343033303233303266303630393261383634383836663730643031303930343331323230343230333232323236336439393239313365333235663163306437643761363331346230343535303337343561363032346633633930313232366166333530626332653330306130363038326138363438636533643034303330323034343733303435303232303537386536353236623062356233306465323562346231343865366632336530626438383631353335613666623865633461396465373338343333633262653530323231303062653834323635333334393162303965376330306437333565323762643865623236373964653462366433613138666434636564386261376565306166383161303030303030303030303030227D
</file>

<file path="apps/uaito/public/examples/career_coach.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Your Name - Career Coach Portfolio</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&family=Playfair+Display:wght@700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
    <link href="https://unpkg.com/aos@2.3.1/dist/aos.css" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto', Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            color: #333;
        }
        h1, h2, h3 {
            font-family: 'Playfair Display', serif;
        }
        header {
            background-color: rgba(44, 62, 80, 0.9);
            color: #ecf0f1;
            text-align: center;
            padding: 1rem;
            position: fixed;
            width: 100%;
            z-index: 1000;
            transition: background-color 0.3s ease;
        }
        header.scrolled {
            background-color: rgba(44, 62, 80, 1);
        }
        nav {
            background-color: transparent;
            padding: 0.5rem;
        }
        nav ul {
            list-style-type: none;
            padding: 0;
        }
        nav ul li {
            display: inline;
            margin-right: 20px;
        }
        nav ul li a {
            color: #ecf0f1;
            text-decoration: none;
            font-weight: bold;
            transition: color 0.3s ease;
        }
        nav ul li a:hover {
            color: #3498db;
        }
        .container {
            width: 80%;
            margin: auto;
            overflow: hidden;
            padding: 20px;
        }
        .btn {
            display: inline-block;
            background: #3498db;
            color: #fff;
            padding: 12px 24px;
            text-decoration: none;
            border-radius: 5px;
            margin-top: 20px;
            transition: background 0.3s ease;
            font-weight: bold;
        }
        .btn:hover {
            background: #2980b9;
        }
        .hero {
            background-image: url('https://picsum.photos/1920/1080');
            background-size: cover;
            background-position: center;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: #fff;
        }
        .hero-content {
            background-color: rgba(0, 0, 0, 0.6);
            padding: 40px;
            border-radius: 10px;
        }
        .services {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
        }
        .service {
            flex-basis: calc(33.333% - 20px);
            background: #f4f4f4;
            margin-bottom: 30px;
            padding: 30px;
            border-radius: 5px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }
        .service:hover {
            transform: translateY(-10px);
        }
        .testimonial {
            background-color: #ecf0f1;
            padding: 40px 0;
            text-align: center;
        }
        .testimonial-content {
            max-width: 800px;
            margin: 0 auto;
        }
        footer {
            background-color: #2c3e50;
            color: #ecf0f1;
            text-align: center;
            padding: 2rem;
        }
        .social-icons {
            margin-top: 20px;
        }
        .social-icons a {
            color: #ecf0f1;
            font-size: 24px;
            margin: 0 10px;
            transition: color 0.3s ease;
        }
        .social-icons a:hover {
            color: #3498db;
        }
        .contact-form {
            background-color: #f4f4f4;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .contact-form fieldset {
            border: none;
            padding: 0;
            margin: 0;
        }
        .contact-form legend {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 20px;
        }
        .form-group {
            margin-bottom: 20px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }
        .form-group input:focus,
        .form-group textarea:focus {
            border-color: #3498db;
            outline: none;
        }
        .form-group textarea {
            height: 120px;
            resize: vertical;
        }
        .submit-btn {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 18px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .submit-btn:hover {
            background-color: #2980b9;
        }
    </style>
</head>
<body>
    <header>
        <h1>Your Name</h1>
        <p>Professional Career Coach</p>
        <nav>
            <ul>
                <li><a href="#home">Home</a></li>
                <li><a href="#about">About</a></li>
                <li><a href="#services">Services</a></li>
                <li><a href="#contact">Contact</a></li>
            </ul>
        </nav>
    </header>

    <section id="home" class="hero">
        <div class="hero-content" data-aos="fade-up">
            <h2>Elevate Your Career</h2>
            <p>Expert guidance to help you reach your professional goals</p>
            <a href="#contact" class="btn">Get Started</a>
        </div>
    </section>

    <div class="container">

        <section id="about" data-aos="fade-up">
            <h2>About Me</h2>
            <img src="https://picsum.photos/300/300" alt="Your Name" style="float: left; margin-right: 20px; border-radius: 50%;">
            <p>With [X] years of experience in career development and coaching, I've helped hundreds of professionals navigate their career paths, overcome challenges, and achieve their dreams. My approach combines industry insights, personalized strategies, and actionable advice to ensure your success.</p>
        </section>

        <section id="services" data-aos="fade-up">
            <h2>My Services</h2>
            <div class="services">
                <div class="service" data-aos="fade-up" data-aos-delay="100">
                    <img src="https://picsum.photos/300/200" alt="Career Assessment" style="width: 100%; border-radius: 5px;">
                    <h3>Career Assessment</h3>
                    <p>Discover your strengths, passions, and ideal career path through comprehensive assessments and guided self-reflection.</p>
                </div>
                <div class="service" data-aos="fade-up" data-aos-delay="200">
                    <img src="https://picsum.photos/300/200" alt="Resume & Portfolio Building" style="width: 100%; border-radius: 5px;">
                    <h3>Resume & Portfolio Building</h3>
                    <p>Craft compelling resumes and portfolios that showcase your unique value proposition to potential employers.</p>
                </div>
                <div class="service" data-aos="fade-up" data-aos-delay="300">
                    <img src="https://picsum.photos/300/200" alt="Interview Preparation" style="width: 100%; border-radius: 5px;">
                    <h3>Interview Preparation</h3>
                    <p>Master the art of interviewing with personalized coaching sessions, mock interviews, and feedback.</p>
                </div>
            </div>
        </section>

        <section class="testimonial" data-aos="fade-up">
            <div class="testimonial-content">
                <h2>What My Clients Say</h2>
                <blockquote>
                    "Working with [Your Name] was a game-changer for my career. Their insights and guidance helped me land my dream job!"
                </blockquote>
                <p>- Jane Doe, Marketing Executive</p>
            </div>
        </section>

        <section id="contact" data-aos="fade-up">
            <h2>Contact Me</h2>
            <p>Ready to take the next step in your career? Get in touch today!</p>
            <div class="contact-form">
                <form>
                    <fieldset>
                        <legend>Send me a message</legend>
                        <div class="form-group">
                            <label for="name">Your Name</label>
                            <input type="text" id="name" name="name" required>
                        </div>
                        <div class="form-group">
                            <label for="email">Your Email</label>
                            <input type="email" id="email" name="email" required>
                        </div>
                        <div class="form-group">
                            <label for="message">Your Message</label>
                            <textarea id="message" name="message" required></textarea>
                        </div>
                        <button type="submit" class="submit-btn">Send Message</button>
                    </fieldset>
                </form>
            </div>
        </section>
    </div>

    <footer>
        <p>&copy; 2023 Your Name - Career Coach. All rights reserved.</p>
        <div class="social-icons">
            <a href="#"><i class="fab fa-facebook"></i></a>
            <a href="#"><i class="fab fa-twitter"></i></a>
            <a href="#"><i class="fab fa-linkedin"></i></a>
            <a href="#"><i class="fab fa-instagram"></i></a>
        </div>
    </footer>

    <script src="https://unpkg.com/aos@2.3.1/dist/aos.js"></script>
    <script>
        AOS.init({
            duration: 1000,
            once: true,
        });

        window.addEventListener('scroll', function() {
            var header = document.querySelector('header');
            header.classList.toggle('scrolled', window.scrollY > 50);
        });
    </script>
</body>
</body>
</html>
</file>

<file path="apps/uaito/public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="apps/uaito/public/vercel.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 283 64"><path fill="black" d="M141 16c-11 0-19 7-19 18s9 18 20 18c7 0 13-3 16-7l-7-5c-2 3-6 4-9 4-5 0-9-3-10-7h28v-3c0-11-8-18-19-18zm-9 15c1-4 4-7 9-7s8 3 9 7h-18zm117-15c-11 0-19 7-19 18s9 18 20 18c6 0 12-3 16-7l-8-5c-2 3-5 4-8 4-5 0-9-3-11-7h28l1-3c0-11-8-18-19-18zm-10 15c2-4 5-7 10-7s8 3 9 7h-19zm-39 3c0 6 4 10 10 10 4 0 7-2 9-5l8 5c-3 5-9 8-17 8-11 0-19-7-19-18s8-18 19-18c8 0 14 3 17 8l-8 5c-2-3-5-5-9-5-6 0-10 4-10 10zm83-29v46h-9V5h9zM37 0l37 64H0L37 0zm92 5-27 48L74 5h10l18 30 17-30h10zm59 12v10l-3-1c-6 0-10 4-10 10v15h-9V17h9v9c0-5 6-9 13-9z"/></svg>
</file>

<file path="apps/uaito/src/actions/index.tsx">
import { createAsyncThunk } from "@reduxjs/toolkit";
import type { Session } from "next-auth";
import { Agent, HuggingFaceONNXModels, HuggingFaceONNXOptions, LLMProvider, Message, MessageArray, MessageInput } from "@uaito/sdk";
import { v4 } from 'uuid';

import type { AppDispatch } from "@/redux/store";
import { pushChatMessage, setDownloadProgress } from "@/redux/userSlice";

interface StreamInput {
  agent?: string,
  session: Session,
  prompt: string,
  inputs: MessageArray<MessageInput>,
  signal: AbortSignal,
  provider?: LLMProvider,
  dispatch: AppDispatch
}

const withWebGPU = [
  LLMProvider.HuggingFaceONNX
]


async function processStream(
  stream: ReadableStream<Uint8Array<ArrayBuffer>>,
  session: Session,
  dispatch: AppDispatch
) {
  let buffer = '';
  const reader = stream.getReader();
  let completed = false;
  while (!completed) {
    const { done, value } = await reader.read();
    if (done) {
      completed = true;
      break;
    }
    const json = Buffer.from(value).toString('utf-8')
    const messages = json.split("<-[*0M0*]->")
    while(messages.length) {
        const [message] = messages.splice(0,1);
        if (message) {
          try {
            const parsed: Message = JSON.parse(buffer+message)
            dispatch(
              pushChatMessage({
                session,
                chatMessage: {
                  message:parsed
                }
              })
            )
            buffer = ''
          } catch (err) {
            buffer += message
          }
        }
    }
  }
  reader.releaseLock()
}


export const getApiKey =  createAsyncThunk(
  'user/key',
  async (options: any, { fulfillWithValue, rejectWithValue }) => {
      try {
        const response = await fetch(`/api/key`);
        return fulfillWithValue(response)
      } catch (error) {
        console.log(error);
        return rejectWithValue(`An error occurred. Please try again later. ${(error as Error).message}`);
      }
  })


export const streamMessage = createAsyncThunk(
  'user/message',
  async (options: StreamInput, { fulfillWithValue, rejectWithValue }) => {
    try {
      const {
        prompt,
        inputs,
        signal,
        dispatch,
      } = options;

      const provider = options.provider ?? LLMProvider.HuggingFaceONNX;
      const agent = options.agent ?? 'orquestrator';
      const userMessage: Message =  {
        role:'user',
        type:'message',
        id: v4(),
        content: [
          { type:'text', text: prompt }
        ]
      }

      dispatch(
        pushChatMessage({
          session:options.session,
          chatMessage: {
            message: userMessage,
          }
        })
      )
      
      if (!withWebGPU.includes(provider)) {
        const url = `/api/${provider}/${agent}/messages`
        const response = await fetch(url, {
          method: 'POST',
          body: JSON.stringify({ 
            prompt,  
            inputs: inputs.map((i) => typeof i.content === 'string'? {...i, content:[{type: 'text', text:i}]}: i)
          }),
          signal: signal,
          credentials: 'include'
        });

        if (!response.ok) {
          return rejectWithValue('An error occurred. Please try again later.');
        }
        if (response.body) {
          await processStream(response.body, options.session, dispatch)
        }
        return fulfillWithValue(null)
      }

      const hfOptions: HuggingFaceONNXOptions = {
        model: HuggingFaceONNXModels.QWEN_1,
        dtype: "q4f16",
        device: "webgpu",
        tools: [],
        onProgress: (progress) => {
          dispatch(setDownloadProgress(progress))
        }
      };

      const __agent = new Agent(
        LLMProvider.HuggingFaceONNX, 
        hfOptions,       
        async function (this: Agent<typeof provider>, message: Message, _signal) { }
      );

      const { response } = await __agent.performTask(
        prompt,
        '',
        `Your name is Uaito.
You are an advanced AI assistant equipped with specialized tools to enhance query resolution. Your responses should be concise, helpful, and factually accurate.

### Key Guidelines
- **Internal Knowledge First**: Only use tools if the user's request explicitly requires information, computation, data retrieval, or verification that exceeds your internal knowledge or capabilities. For questions you can answer directly from your training data (up to your knowledge cutoff), respond immediately without tools.
- **Step-by-Step Reasoning**: For every user query, think step-by-step in your internal reasoning (enclosed in <thinking> tags, which are not shown to the user). Analyze the query, check conversation history for context, determine if tools are strictly necessary, and plan your approach. If tools are needed, select the most relevant one(s) and explain why in your thinking.
- **Conversation History**: Always reference the full conversation history, including past user messages, your responses, tool calls, and their results. Use this to maintain context, chain operations logically, avoid redundant tool calls, and build on previous steps. If a similar tool was used recently and its result is still valid/relevant, reference it instead of re-running unless the query demands fresh data or recomputation.
- **Multi-Step Processes**: Break down complex queries into sequential steps. Use tools iteratively across turns if needed (e.g., use one tool's output as input for another). Do not attempt to resolve everything in one response if it requires chaining.
- **Efficiency and Relevance**: Prioritize the fewest, most targeted tool calls. Invoke multiple tools in parallel only if they provide independent value without overlap. Craft precise arguments to get focused outputs.
- **Error Handling**: If a tool returns an error, describe the issue clearly in your response, suggest alternatives (e.g., rephrasing the query or using a different tool), and do not fabricate results.
- **Final Response**: After reasoning (and any tool calls), provide a direct, user-facing answer. If tools were used, incorporate their results seamlessly without mentioning the tools unless relevant to the explanation.

### Tool Usage Format
To use tools, output function calls in this exact XML format before your final response. Use <tool_call> and </tool_call> tags. You can call multiple tools in sequence or parallel by listing them one after another.
Do not escape arguments; they are parsed as plain text. After tool results are provided (in the next system message), continue reasoning based on them and output your final response without further tool calls unless needed.

If no tools are required, skip tool calls and go straight to your response.

### Response Structure
- Start with <think>your step-by-step reasoning here</think> (internal only).
- If using tools, output the tool call(s) immediately after thinking.
- After tool results (in subsequent interactions), end with your final, user-facing response. Do not include thinking or tool calls in the final output to the user.

Maintain neutrality, avoid verbosity, and focus on delivering value.`,
        true
      );
      
      // Convert ReadableStream<Message> to ReadableStream<Uint8Array>
      const uint8ArrayStream = new ReadableStream<any>({
        start(controller) {
          const reader = response.getReader();
          
          async function pump() {
            try {
              while (true) {
                const { done, value } = await reader.read();
                if (done) {
                  controller.close();
                  break;
                }
                
                // Serialize the Message to JSON and encode as Uint8Array
                const jsonString = JSON.stringify(value) + "<-[*0M0*]->";
                const uint8Array = new TextEncoder().encode(jsonString);
                controller.enqueue(uint8Array);
              }
            } catch (error) {
              controller.error(error);
            }
          }
          
          pump();
        }
      });

      await processStream(uint8ArrayStream, options.session, dispatch)

      return fulfillWithValue(null)
    } catch (error) {
      debugger;
      options.dispatch(setDownloadProgress(0))
      return rejectWithValue('An error occurred. Please try again later.' + (error as Error).message);
    }
  }
)
</file>

<file path="apps/uaito/src/ai/agents/AutomatedEngineer.ts">
import fs from 'fs-extra';
import type { Browser } from "playwright";
import { Agent, LLMProvider, type AgentTypeToOptions, type MessageInput, type OnTool, ANSI_BLUE, type Tool, MessageArray } from "@uaito/sdk";
import { chromium } from "playwright";
import { runTavilySearch } from '../tools/tavily';
import { extractAllText } from '../tools/extractWebContent';
import {  safeCommands } from '../../config';


export class AutomatedEngineer<T extends LLMProvider> extends Agent<T> {
    protected color = ANSI_BLUE;
    protected name = "Engineer"
    public override tools: Tool[]
  
    constructor(
      public type: T,
      protected llmOptions:AgentTypeToOptions[typeof type],
      protected onTool: OnTool,
      protected directory: string,
      public inputs: MessageArray<MessageInput>,
      public systemPrompt: string,
    
    ) {
      //TODO
      const tools = llmOptions.tools ?? [];
      super(type, llmOptions, onTool, inputs, tools)
      this.tools = tools;
    }
  
    createInitialMessageInput(prompt: string, input: MessageArray<MessageInput>): MessageArray<MessageInput> {
      const chainOfThought = `Answer the user's request using relevant tools only if the tool exists. 
  Before calling a tool, do some analysis within <thinking></thinking> tags. 
  1. First, determine if you have access to the requested tool.
  2. Second, think about which of the provided tools is the relevant tool to answer the user's request. 
  3. Third, go through each of the required parameters of the relevant tool and determine if the user has directly provided or given enough information to infer a value. 
  When deciding if the parameter can be inferred, carefully consider all the context to see if it supports a specific value.
  If all of the required parawmeters are present or can be reasonably inferred, close the thinking tag and proceed with the tool call. 
  BUT, if one of the values for a required parameter is missing, 
  DO NOT invoke the function (not even with fillers for the missing params) and instead, ask the user to provide the missing parameters. 
  DO NOT ask for more information on optional parameters if it is not provided.
  DO NOT reflect on the quality of the returned search results in your response.`
      input.push({
        role: 'user',
        content: [{
          text: `${prompt}\r\n\r\n${chainOfThought}`, type: 'text'
        }]
      })
  
      return input;
    }
  



    safeCommand(command: string) {
      const commands = command.split("&&");
      commands.forEach((splitCommand) => {
        const shellCommand = splitCommand.trim().split(" ")[0]
        if (!safeCommands.includes(shellCommand)) {
          throw new Error("Unsupported command " + shellCommand)
        }
      })
      return command
    }
  
    get cwd() {
      const directory = this.directory
      if (!fs.existsSync(directory)) {
        fs.mkdirSync(directory)
      }
      return directory;
    }
  
    async tavilySearch(query: string): Promise<any[]> {
      const result = await runTavilySearch(query);
      const content = [
        {
          type:'text',
          text: result.answer
        }
      ]
      result.images.map((img: string) => {
        content.push({type:'text', text:`Image ${img}\r\n`})
      });
      return content
    }
  
    async browseWebPage(url: string, extractText: boolean): Promise<string> {
      let browser:Browser;
        browser =  await chromium.launch( {
      headless: true
      });
      const context = await browser.newContext({
        userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
      });
  
      const page = await context.newPage();
      
      await page.goto(url, { timeout: 30000, waitUntil: 'domcontentloaded' });
      
      if (extractText) {
        const response = await extractAllText(page);
        await browser.close()
        return response
      } else {
        return page.content()
      }
    }
  
  }
</file>

<file path="apps/uaito/src/ai/agents/Editor.ts">
import { Agent, Tool,  MessageInput, SearchReplaceBlock, ANSI_YELLOW, MessageArray, LLMProvider } from "@uaito/sdk";

export class Editor extends Agent<LLMProvider.Anthropic> {
    protected color = ANSI_YELLOW;
    protected name = "Editor";
    public inputs: MessageArray<MessageInput> = MessageArray.from([]);
    protected _systemPrompt: string = `You are an AI coding agent that generates edit instructions for code files. Your task is to analyze the provided code and generate SEARCH/REPLACE blocks for necessary changes. Follow these steps:

    1. Review the entire file content to understand the context:
    $$file_content

    2. Carefully analyze the specific instructions:
    $$instructions

    3. Take into account the overall project context:
    $$project_context

    4. Consider the memory of previous edits:
    $$memory_context

    5. Consider the full context of all files in the project:
    $$full_file_contents_context

    6. Generate SEARCH/REPLACE blocks for each necessary change. Each block should:
       - Include enough context to uniquely identify the code to be changed
       - Provide the exact replacement code, maintaining correct indentation and formatting
       - Focus on specific, targeted changes rather than large, sweeping modifications

    7. Ensure that your SEARCH/REPLACE blocks:
       - Address all relevant aspects of the instructions
       - Maintain or enhance code readability and efficiency
       - Consider the overall structure and purpose of the code
       - Follow best practices and coding standards for the language
       - Maintain consistency with the project context and previous edits
       - Take into account the full context of all files in the project

    IMPORTANT: RETURN ONLY THE SEARCH/REPLACE BLOCKS. NO EXPLANATIONS OR COMMENTS.
    USE THE FOLLOWING FORMAT FOR EACH BLOCK:

    <SEARCH>
    Code to be replaced
    </SEARCH>
    <REPLACE>
    New code to insert
    </REPLACE>

    If no changes are needed, return an empty list.
`

public  tools: Tool[] = []
    private fileContent!: string;
    private instructions!: string;
    private projectContext!: string;
    private memoryContext!: string;
    private fullFileContentsContext!: string;


    get systemPrompt() {
        return this._systemPrompt
            .replace("$$file_content", this.fileContent)
            .replace("$$instructions", this.instructions)
            .replace("$$project_context", this.projectContext)
            .replace("$$memory_context", this.memoryContext)
            .replace("$$full_file_contents_context", this.fullFileContentsContext)
    }

    createInitialMessageInput(
        prompt: string, 
        input: MessageArray<MessageInput>
    ): MessageArray<MessageInput> {
        input.push({ role: 'user', content: [{ text: prompt, type: 'text' }] });
        return input;
    }

    parseSearchReplaceBlocks(responseText: string): SearchReplaceBlock[] {
        const blocks: SearchReplaceBlock[] = [];
        const lines = responseText.split('\n');
        let currentBlock: { search?: string[], replace?: string[] } = {};
        let currentSection: 'search' | 'replace' | null = null;

        for (const line of lines) {
            const trimmedLine = line.trim();
            if (trimmedLine === '<SEARCH>') {
                currentSection = 'search';
                currentBlock.search = [];
            } else if (trimmedLine === '</SEARCH>') {
                currentSection = null;
            } else if (trimmedLine === '<REPLACE>') {
                currentSection = 'replace';
                currentBlock.replace = [];
            } else if (trimmedLine === '</REPLACE>') {
                currentSection = null;
                if (currentBlock.search && currentBlock.replace) {
                    blocks.push({
                        search: currentBlock.search.join('\n'),
                        replace: currentBlock.replace.join('\n')
                    });
                }
                currentBlock = {};
            } else if (currentSection) {
                currentBlock[currentSection]!.push(line);
            }
        }

        return blocks;
    }

    async request(
        inputPath: string,
        originalContent: string,
        instructions: string,
        projectContext: string,
        fileContents: { [name: string]: string }
    ) {
        const code_editor_files: string[] = [];
        const code_editor_memory: string[] = [];
        const memoryContext: string = code_editor_memory
            .map((mem, i) => `Memory ${i + 1}:\n${mem}`)
            .join('\n');

        const fullFileContentsContext: string = Object.entries(fileContents)
            .filter(([path, _]) => path !== inputPath || !code_editor_files.includes(path))
            .map(([path, content]) => `--- ${path} ---\n${content}`)
            .join('\n\n');

        this.fileContent = originalContent;
        this.instructions = instructions;
        this.projectContext = projectContext;
        this.memoryContext = memoryContext;
        this.fullFileContentsContext = fullFileContentsContext;

        const response = await this.performTask(
            "Generate SEARCH/REPLACE blocks for the necessary changes.",
            this.systemPrompt,
            '',
            false
        );
        return response;
    }



}
</file>

<file path="apps/uaito/src/ai/agents/Execution.ts">
import { Agent, type MessageInput, ANSI_YELLOW, type Tool, MessageArray, LLMProvider } from "@uaito/sdk";

export class Execution extends Agent<LLMProvider.Anthropic> {
    protected override color = ANSI_YELLOW;
    protected override name = "Executor"
    protected _systemPrompt: string = `You are an AI code execution agent. 
    Your task is to analyze the provided code and its execution result from the 'code_execution_env' virtual environment, then provide a concise summary of what worked, what didn't work, and any important observations. Follow these steps:
    1. Review the code that was executed in the 'code_execution_env' virtual environment:
    $$command

    2. Analyze the execution result from the 'code_execution_env' virtual environment:
    $$result

    3. Provide a brief summary of:
       - What parts of the code executed successfully in the virtual environment
       - Any errors or unexpected behavior encountered in the virtual environment
       - Potential improvements or fixes for issues, considering the isolated nature of the environment
       - Any important observations about the code's performance or output within the virtual environment
       - If the execution timed out, explain what this might mean (e.g., long-running process, infinite loop)

    Be concise and focus on the most important aspects of the code execution within the 'code_execution_env' virtual environment.
    IMPORTANT: PROVIDE ONLY YOUR ANALYSIS AND OBSERVATIONS. DO NOT INCLUDE ANY PREFACING STATEMENTS OR EXPLANATIONS OF YOUR ROLE.`
    public override tools: Tool[] = []

    public override inputs: MessageArray<MessageInput> = MessageArray.from([]);
    private code!: string;
    private execution_result!: string;

    get systemPrompt() {
        return this._systemPrompt
            .replace("$$command", this.code)
            .replace("$$result", this.execution_result)
    }

    createInitialMessageInput(
        prompt: string, 
        input: MessageArray<MessageInput>
    ): MessageArray<MessageInput> {
        input.push({ role: 'user', content: [{type:'text', text:prompt}]});
        return input;
    }

    async request(code: string, execution_result: string) {
        this.code = code;
        this.execution_result = execution_result;
        const prompt = `Analyze this code execution from the 'code_execution_env' virtual environment:\n\nCode:\n${code}\n\nExecution Result:\n${execution_result}`
        return this.performTask(
            prompt,
            "",
            this.systemPrompt,
            false
        )
    }
}
</file>

<file path="apps/uaito/src/ai/agents/onTool.ts">
import { Agent, ToolUseBlock, Message, LLMProvider, type MessageInput, MessageArray, type AgentTypeToOptions  } from "@uaito/sdk";
import type { AutomatedEngineer } from "./AutomatedEngineer";
import { ToolModel } from '@/db/models/Tool';
import type {AbortSignal} from 'abort-controller';
import { AbortController } from 'abort-controller';
import { Execution } from "./Execution";
import { AnthropicModels } from "@uaito/sdk";
async function toolCompletion(id: string, signal: AbortSignal) {
    const maxRetries = 400;
    for (let retries = 0; retries < maxRetries; retries++) {
        if (signal.aborted) {
            throw new Error('Operation aborted');
        }
        const toolStatus = await ToolModel.findOne({
            _id:id
        });
        if (toolStatus && toolStatus.state === 'completed') {
            console.log('Tool status is completed');
            return toolStatus;
        }
        await new Promise((resolve) => {
            const timer = setTimeout(resolve, 1000);
            signal.addEventListener('abort', () => {
                clearTimeout(timer);
                resolve(null);
            }, { once: true });
        });
    }

    throw new Error('Tool completion timed out');
}

export async function onTool<T extends LLMProvider>(
    this: Agent<T>,
    userId: string,
    threadId: string,
    message: Message,
    inputs: MessageArray<MessageInput>,
    abortController: AbortController
) {
    const { content } = message;
    if (typeof content === "string") {
        throw new Error("You must use ToolUseBlockParam on onTool content, string is not yet supported")
    }
    const tool = content.find(
        (content): content is ToolUseBlock => content.type === 'tool_use',
    );
    if (!tool) {
        throw new Error("Could not find ToolUseBlockParam on onTool")
    }
    const canUse = this.tools.find((toolN) => toolN.name === tool.name)
    if (!canUse) {
        throw new Error(`Invalid tool ${tool.name} is not enabled in your subscription`)
    }

    const localTools = ['tavilySearch', 'browseWebPage'];
    const toolName = tool.name as any;
    const toolFunction = (this as any)[toolName];

    const agentOptions = this.options as AgentTypeToOptions[T];
    if (agentOptions) {
        agentOptions.tools = [];
        (agentOptions as any).inputs = MessageArray.from([])
    }

    const execution = new Execution(LLMProvider.Anthropic, {
        ...agentOptions,
        model: AnthropicModels['claude-4-sonnet'],
        maxTokens: 4096
    })
    if (localTools.includes(tool.name)) {

        if (tool.name === "browseWebPage" && typeof toolFunction === 'function') {
            await this.runSafeCommand(
                tool,
                async (instance) => {
                    const codeInput = tool.input as any;
                    const key = tool.name as any;
                    const method = (instance as any)[key];
                    if (!method || typeof method !== 'function') {
                        throw new Error(`The method ${method} does not exist in AutomatedEngineer, must be implemented first.`)
                    }
                    const result = await method.bind(this)(codeInput.url, codeInput.extractText ?? false);
                    (this.inputs as MessageArray<MessageInput>).push({
                        role:'user',
                        content:[{
                            name: tool.name,
                            type: 'tool_result',
                            tool_use_id: tool.id,
                            content: [
                                {
                                    "type": "text",
                                    "text": result
                                }
                            ],
                        }]
                    })
                })
        } else if (tool.name === "tavilySearch" && typeof toolFunction === 'function') {
            await this.runSafeCommand(
                tool,
                async (instance: AutomatedEngineer<T>) => {
                    const codeInput = tool.input as any;
                    const key = tool.name as any;
                    const method = (instance as any)[key];
                    if (!method || typeof method !== 'function') {
                        throw new Error(`The method ${method} does not exist in AutomatedEngineer, must be implemented first.`)
                    }
                    const list = await method.bind(this)(codeInput.query)
                    inputs.push({
                        role:'user',
                        content: [
                            {
                                name: tool.name,
                                type: 'tool_result',
                                tool_use_id: tool.id,
                                content: list
                            }
                        ]
                    })
                }
            )
        }
    } else {
        const dbTool = await ToolModel.create({
            userId,
            threadId,
            name: toolName,
            input: JSON.stringify(tool.input),
            state: 'pending'
        })
        try {
            const completed = await toolCompletion(dbTool._id as string, abortController.signal);
            const input = JSON.parse(completed.input ?? '{}');
            if (completed) {
                if (toolName === "executeCommand") {
                    const response = JSON.parse(completed.content)[0].text;
                    const executionAnalize = await execution.request(input.code, response)
                    
                    inputs.push({
                        role:'user',
                        content: [
                            {
                                name: tool.name,
                                type: 'tool_result',
                                tool_use_id: tool.id,
                                isError: completed.error,
                                content: [
                                    {
                                        type: 'text',
                                        text: ((executionAnalize.response as Message).content[0] as any).text
                                    }
                                ]
                            }
                        ]
                    })
                }  else {
                    inputs.push({
                        role:'user',
                        content: [
                            {
                                name: tool.name,
                                type: 'tool_result',
                                isError: completed.error,
                                tool_use_id: tool.id,
                                content: JSON.parse(completed.content)
                            }
                        ]
                    })
                }
            }
        } catch (err: unknown) {
            abortController.abort()
        }
    }
}
</file>

<file path="apps/uaito/src/ai/prompts/AutomatedEngineer.ts">
import { Tool } from "@uaito/sdk"

const fsTools = [
   "editAndApply",
   "createFile",
   "createFolder",
   "readFile",
   "listFiles",
   "executeCommand"
]

export const createChainOfThought = (tools: Tool[]) => {

   const hasFS = fsTools.some((tool) => tools.some((utool) => utool.name === tool));

   let capabilities = hasFS ?

   [
      'Creating and managing project structures',
      'Writing, debugging, and improving code across multiple languages',
      'Providing architectural insights and applying design patterns',
      'Staying current with the latest technologies and best practices',
      'Analyzing and manipulating files within the project directory',
      'Performing web searches for up-to-date information',
      'Executing code and analyzing its output within an isolated \'code_execution_env\' virtual environment'
   ]

   :

   [
      'Writing, debugging, and improving code across multiple languages',
      'Providing architectural insights and applying design patterns',
      'Staying current with the latest technologies and best practices',
      'Performing web searches for up-to-date information',
   ]

   const usageGuidelines = hasFS ? [
      'Always use the most appropriate enabled tool for the task at hand.',
      //This 2 should be moved probably to the editor directly
      'Provide detailed and clear instructions when using tools, especially for edit_and_apply',
      'After making changes, always review the output to ensure accuracy and alignment with intentions.',
      'Use execute_code to run and test code within the \'code_execution_env\' virtual environment, then analyze the results.',
      'Proactively use tavilySearch when you need up-to-date information or additional context.'
   ] : [
      'When tool is activated, use most appropiate tool BUT dont disabled tools.',
      'Proactively use tavilySearch when you need up-to-date information or additional context.'
   ]
   return `You are Orquestrator, an AI assistant specialized in software development with access to a variety of tools and the ability to instruct and direct a coding agent and a code execution one. Your capabilities include:

${capabilities.map((capability, i) => `${i+1}. ${capability}`).join("\r\n")}

Available tools and their optimal use cases:
${tools.map((tool, i) => `${i+1}. ${tool.name}`).join("\r\n")}

Tool Usage Guidelines:
${usageGuidelines.map((usage) => `- ${usage}`).join("\r\n")}

Error Handling and Recovery:
- If a tool operation fails, carefully analyze the error message and attempt to resolve the issue.${hasFS ? '\r\n- For file-related errors, double-check file paths and permissions before retrying.':''}\r\n- If a search fails, try rephrasing the query or breaking it into smaller, more specific searches.${hasFS ? '\r\n- If code execution fails, analyze the error output and suggest potential fixes, considering the isolated nature of the environment.': ''}

${hasFS ? `Project Creation and Management:
1. Start by creating a root folder for new projects.
2. Create necessary subdirectories and files within the root folder.
3. Organize the project structure logically, following best practices for the specific project type.`:''}

Always strive for accuracy, clarity, and efficiency in your responses and actions. Your instructions must be precise and comprehensive. 
If uncertain, use the tavilySearch tool or admit your limitations. 
When executing code, always remember that it runs in the isolated 'code_execution_env' virtual environment. 
Be aware of any long-running processes you start and manage them appropriately, including stopping them when they are no longer needed.

When using tools:
1. Carefully consider if a tool is necessary before using it.
2. Ensure all required parameters are provided and valid.
3. Handle both successful results and errors gracefully.
4. Provide clear explanations of tool usage and results to the user.

Remember, you are an AI assistant, and your primary goal is to help the user accomplish their tasks effectively and efficiently while maintaining the integrity and security of their development environment.

You are currently in automode. Follow these guidelines:

1. Goal Setting:
   - Set clear, achievable goals based on the user's request.
   - Break down complex tasks into smaller, manageable goals.

2. Goal Execution:
   - Work through goals systematically, using appropriate tools for each task.
   - Utilize file operations, code writing, and web searches as needed.
   - Always read a file before editing and review changes after editing.

3. Progress Tracking:
   - Provide regular updates on goal completion and overall progress, except if the task just completed.

4. Tool Usage:
   - Leverage all available tools to accomplish your goals efficiently.
   ${hasFS ?'- Prefer edit_and_apply for file modifications, applying changes in chunks for large edits.\r\n' : ''}- Use tavilySearch proactively for up-to-date information.

5. Error Handling:
   - If a tool operation fails, analyze the error and attempt to resolve the issue.
   - For persistent errors, consider alternative approaches to achieve the goal.

6. Automode Completion:
   - When all goals are completed, you will not re-iterate.
   - Do not ask for additional tasks or modifications once goals are achieved.
   
7. Iteration Awareness:
   - Use this information to prioritize tasks and manage time effectively.


Remember: Focus on completing the established goals efficiently and effectively. Avoid unnecessary conversations or requests for additional tasks.`
}
</file>

<file path="apps/uaito/src/ai/tools/extractWebContent.ts">
import {  Page } from 'playwright';


export async function extractAllText(page: Page, customSelector?: string): Promise<string> {
  return await page.evaluate((selector) => {
    const ignoredTags = ['SCRIPT', 'STYLE', 'NOSCRIPT', 'IFRAME', 'SVG'];
    const ignoredClasses = ['nav', 'navbar', 'header', 'footer', 'sidebar', 'ad', 'advertisement', 'menu'];
    
    function shouldIgnoreElement(element: Element): boolean {
      if (ignoredTags.includes(element.tagName)) return true;
      
      for (const className of ignoredClasses) {
        if (element.classList.contains(className) || element.id.toLowerCase().includes(className)) {
          return true;
        }
      }
      
      return false;
    }

    function extractTextFromElement(element: Element): string {
      if (shouldIgnoreElement(element)) return '';

      let text = '';
      for (const child of Array.from(element.childNodes)) {
        if (child.nodeType === Node.TEXT_NODE) {
          const trimmedText = (child.textContent || '').trim();
          if (trimmedText) {
            text += trimmedText + ' ';
          }
        } else if (child.nodeType === Node.ELEMENT_NODE) {
          text += extractTextFromElement(child as Element);
        }
      }
      return text.trim();
    }

    let rootElement: Element | null;
    if (selector) {
      rootElement = document.querySelector(selector);
      if (!rootElement) {
        console.warn(`Custom selector "${selector}" not found. Falling back to body.`);
        rootElement = document.body;
      }
    } else {
      rootElement = document.body;
    }

    return extractTextFromElement(rootElement).trim().replace(/\s+/g, ' ');
  }, customSelector);
}
</file>

<file path="apps/uaito/src/ai/tools/tavily.ts">
import axios, { AxiosError } from 'axios';

// Define the structure of a Tavily search result
 interface TavilySearchResult {
  title: string;
  url: string;
  content: string;
  score: number;
}

// Define the structure of the Tavily API response
 interface TavilyApiResponse {
  results: TavilySearchResult[];
  query: string;
  answer?: string;
  images: string[]
}

/**
 * Run a Tavily search query and parse the results
 * @param query The search query string
 * @param apiKey Your Tavily API key
 * @param includeAnswer Optional: Include an AI-generated answer in the response
 * @param searchDepth Optional: Set the search depth to 'basic' or 'advanced'
 * @returns A promise that resolves to an array of TavilySearchResult objects
 */
async function runTavilySearch(
  query: string,
  searchDepth: 'basic' | 'advanced' = 'advanced'
): Promise<TavilyApiResponse> {
  try {
    const response = await axios.post<TavilyApiResponse>('https://api.tavily.com/search',{
      api_key: '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',
      query: query,
      include_answer: true,
      search_depth: 'advanced',
      include_images: true
    });
    return response.data
  } catch (error) {
    console.error('Error running Tavily search:', error);
    if (axios.isAxiosError(error)) {
      const axiosError = error as AxiosError;
      console.error('Axios error details:', axiosError.response?.data);
    }
    throw error;
  }
}

export type { TavilySearchResult };
export { runTavilySearch};
</file>

<file path="apps/uaito/src/ai/config.ts">
type GenericAgentConfig = {
    systemPrompt: string,
    chainOfThought: string,
}

const schema = `{
   "type": "object",
   "properties": {
     "name": {
       "type": "string"
     },
     "lastName": {
       "type": "string"
     },
     "email": {
       "type": "string"
     },
     "phone": {
       "type": "string",
       "description": "Phone number is any number and can contain country codes too, +34 or any other."
     },
     "address":{
       "type": "object",
       "properties": {
         "city": {
           "type": "string"
         },
         "fullAddress":  {
           "type": "string"
         },
         "postal": {
           "type": "string"
         }
       },
       "required":["city", "fullAddress", "postal"]
     },
     "renovation":{
       "type":"object",
       "properties": {
         "type": {
           "type":"string",
           "description": "can be paintjob or floor-renovation"
         },
         "m2"{
           "type": "string",
           "description": "the aproximate number of square meters for the job"
         },
         "message":{
           "type":"string",
           "description":"What is the customer renovation about, color, type of floor or paint?"
         }
       }
     }
   },
   "required": ["name", "lastName", "email", "phone", "address"]
 }`;

 export const createExperimentalConfig = (messages: string[]):GenericAgentConfig => {
   const systemPrompt = `
You are assisting as a customer service agent for a home renovation business that offers painting and flooring renovation services. 
Your goal is to gather required information from the customer step by step to create a structured JSON object.
SCHEMA:
   - Follow the schema provided to know which fields are required and what type of data is expected.
   ${schema}
   - If all required fields are collected, you will respond ONLY with the completed JSON object.
   - If any required fields are missing, you will prompt the user to provide them step by step.

REPLIES:
   - If all required fields are collected, you will respond ONLY with the completed JSON object.
   - If any required fields are missing, you will prompt the user to provide them step by step.
   - Do not add extra text when the JSON object is ready. Respond strictly in JSON format.

CONVERSATION HISTORY:
${ messages.join("")}`
 
const chainOfThought = `To effectively extract customer dats, you will follow these requirements:

1. Extraction process:
   Communicate with the customer in a friendly and logical way following the rules of the conversation, u will request information in order.
   - Group 1: Ask for basic information (name, lastName).
   - Group 2: Ask for contact information (phone, email).
   - Group 3: Ask for address information (city, fullAddress, postal).
   - Group 4: Ask for work information (type, m2, message).

2. Asking for information:
   - Personalize the interaction by using the fields already provided.
   - Follow a logical and friendly progression based on the information missing.
   - Consider all properties of the json schema and any sub-property as required.
   - Have confidence in your decisions if the information is ready, complete your task

3. VALID Examples:

   - Some fields are missing:
   input: {"name": "Javier"}
   response: Hello Javier, can you provide me your last name?

   - All fields are ready:
   input: {"name": "Javier", "lastName": "Ribo", "email": "elribonazo@gmail.com", "phone": "123456789"}
   response:
   {"name": "Javier", "lastName": "Ribo", "email": "elribonazo@gmail.com", "phone": "123456789"}

4. INVALID Examples:
   - Avoid this kind of output when complete:
   input: {"name": "Javier", "lastName": "Ribo", "email": "elribonazo@gmail.com", "phone": "123456789"}
   reasoning: This response would be invalid because we must respond PURELY with JSON object, no extra text should be added.
   response:
   Great, thank you for providing all the required information. 
   Here's the JSON:
   {"name": "Javier", "lastName": "Ribo", "email": "elribonazo@gmail.com", "phone": "123456789"}
`;
   return {
    systemPrompt,
    chainOfThought
   }
 }
</file>

<file path="apps/uaito/src/ai/tools.ts">
import { Tool } from "@uaito/sdk";



export const executeCommandTool: Tool = {
  name: "executeCommand",
  description: "Execute commands in a unix shell. This tool should be used when you need to run code and see its output or check for errors. All code execution happens exclusively in this isolated environment. The tool will return the standard output, standard error, and return code of the executed code. Long-running processes will return a process ID for later management.",
  input_schema: {
    type: "object",
    properties: {
      code: {
        type: "string",
        description: "The code to run in the unix environment. Make sure that it is a valid unix command"
      }
    },
    required: ["code"]
  }
};


export const createFolderTool: Tool = {
  name: "createFolder",
  description: "Create directories. This tool is used to create directories inside the current workspace",
  input_schema: {
    type: "object",
    properties: {
      path: {
        type: "string",
        description: "the directory"
      }
    },
    required: ["path"]
  }
};


export const createFileTool: Tool = {
  name: "createFile",
  description: "Create a new file at the specified path with the given content. This tool should be used when you need to create a new file in the project structure. It will create all necessary parent directories if they don't exist. The tool will return a success message if the file is created, and an error message if there's a problem creating the file or if the file already exists. The content should be as complete and useful as possible, including necessary imports, function definitions, and comments.",
  input_schema: {
    type: "object",
    properties: {
      path: {
        type: "string",
        description: "The absolute or relative path where the file should be created. Use forward slashes (/) for path separation, even on Windows systems."
      },
      content: {
        type: "string",
        description: "Optional parameter to provide the file contents as plain text"
      },
      contentMimeType: {
        type: "string",
        description: "If not concretely specified will configure one by default based on the content"
      },
      encoding: {
        type: "string",
        description: "Optional parameter that can be 'plainText' or 'base64' and define the content's encoding, by default will be set based on the content"
      }
    },
    required: ["path"]
  }
}


export const editAndApplyTool: Tool = {
  name: "editAndApply",
  description: "Apply AI-powered improvements to a file based on specific instructions and detailed project context. This function reads the file, processes it in batches using AI with conversation history and comprehensive code-related project context. It generates a diff and allows the user to confirm changes before applying them. The goal is to maintain consistency and prevent breaking connections between files. This tool should be used for complex code modifications that require understanding of the broader project context.",
  input_schema: {
    type: "object",
    properties: {
      path: {
        type: "string",
        description: "The absolute or relative path of the file to edit. Use forward slashes (/) for path separation, even on Windows systems."
      },
      original_content: {
        type: 'string',
        description: 'Contains the content of the original file we want to edit'
      },
      instructions: {
        type: "string",
        description: "After completing the code review, construct a plan for the change between <PLANNING> tags. Ask for additional source files or documentation that may be relevant. The plan should avoid duplication (DRY principle), and balance maintenance and flexibility. Present trade-offs and implementation choices at this step. Consider available Frameworks and Libraries and suggest their use when relevant. STOP at this step if we have not agreed a plan.\n\nOnce agreed, produce code between <OUTPUT> tags. Pay attention to Variable Names, Identifiers and String Literals, and check that they are reproduced accurately from the original source files unless otherwise directed. When naming by convention surround in double colons and in ::UPPERCASE::. Maintain existing code style, use language appropriate idioms. Produce Code Blocks with the language specified after the first backticks"
      },
      project_context: {
        type: "string",
        description: "Comprehensive context about the project, including recent changes, new variables or functions, interconnections between files, coding standards, and any other relevant information that might affect the edit."
      }
    },
    required: ["path", "instructions", "project_context"]
  }
}

export const readFileTool: Tool = {
  name: "readFile",
  description: "Read the contents of a file at the specified path. This tool should be used when you need to examine the contents of an existing file. It will return the entire contents of the file as a string. If the file doesn't exist or can't be read, an appropriate error message will be returned.",
  input_schema: {
    type: "object",
    properties: {
      path: {
        type: "string",
        description: "The absolute or relative path of the file to read. Use forward slashes (/) for path separation, even on Windows systems."
      }
    },
    required: ["path"]
  }
}
export const listFilesTool: Tool = {
  name: "listFiles",
  description: "List all files and directories in the specified folder. This tool should be used when you need to see the contents of a directory. It will return a list of all files and subdirectories in the specified path. If the directory doesn't exist or can't be read, an appropriate error message will be returned.",
  input_schema: {
    type: "object",
    properties: {
      path: {
        type: "string",
        description: "The absolute or relative path of the folder to list. Use forward slashes (/) for path separation, even on Windows systems. If not provided, the current working directory will be used."
      }
    }
  }
}
export const browseWebPageTool: Tool = {
  name: "browseWebPage",
  description: `Opens the desired url to either get the source html code or to directly extract the redable texts`,
  input_schema: {
    type: "object",
    properties: {
      url: {
        type: "string",
        description: "The url parameter must include http or https or file."
      },
      extractText: {
        type: 'boolean',
        description: "If true, will return the content texts only. When not specified, or when false, we will return the whole html code."
      }
    },
    required: ['url']
  }
}

export const tavilySearch: Tool = {
  name: "tavilySearch",
  description: "Perform a web search using the Tavily API to get up-to-date information or additional context. This tool should be used when you need current information or feel a search could provide a better answer to the user's query. It will return a summary of the search results, including relevant snippets and source URLs.",
  input_schema: {
    type: "object",
    properties: {
      query: {
        type: "string",
        description: "The search query. Be as specific and detailed as possible to get the most relevant results."
      }
    },
    required: ["query"]
  }
}
</file>

<file path="apps/uaito/src/app/globals.css">
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@300;400;700&display=swap');

@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 214, 219, 220;
  --background-end-rgb: 255, 255, 255;
  --font-inter: 'Inter', sans-serif;
}

@media (prefers-color-scheme: dark) {
  :root {
    --foreground-rgb: 229, 231, 235;
    --background-start-rgb: 17, 24, 39;
    --background-end-rgb: 31, 41, 55;
    --accent-color: 59, 130, 246;
  }

  a {
    color: rgb(var(--accent-color));
    transition: color 0.3s;
  }

  a:hover {
    color: rgb(129, 140, 248);
  }
}

body {
  color: rgb(var(--foreground-rgb));
  background: linear-gradient(
      to bottom,
      transparent,
      rgb(var(--background-end-rgb))
    )
    rgb(var(--background-start-rgb));
  text-shadow: 0 0 1px rgba(0, 0, 0, 0.1);
  font-family: var(--font-inter);
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }

  .text-accent {
    color: rgb(var(--accent-color));
  }
}


.font-orbitron {
  font-family: 'Orbitron', sans-serif;
}

.fade-in {
  opacity: 0;
  transform: translateY(20px);
  transition: opacity 0.5s ease-out, transform 0.5s ease-out;
}

.fade-in-section {
  opacity: 1;
  transform: translateY(0);
}

@keyframes gradient-animation {
  0% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
  100% {
    background-position: 0% 50%;
  }
}

.animate-gradient-text {
  background-size: 200% 200%;
  animation: gradient-animation 5s ease infinite;
}


.feature-card {
  border: 1px solid rgba(255, 255, 255, 0.1);
  box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
}
.feature-card:hover {
  box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.6);
}
</file>

<file path="apps/uaito/src/app/layout.tsx">
import type { Metadata } from 'next'



export const metadata: Metadata = {
  title: 'UAITO - AI-Powered Engineering Automation | Boost Productivity',
  description: 'Revolutionize your engineering tasks with UAITO, the advanced AI-powered automation tool. Enhance productivity, streamline workflows, and accelerate development.',
  keywords: 'AI-powered engineering, automation tool, productivity, software development, AI-assisted coding',
  openGraph: {
    title: 'UAITO - AI-Powered Engineering Automation',
    description: 'Boost productivity with AI-assisted coding and automated tasks for engineers and developers.',
    type: 'website',
    url: 'https://www.uaito.com',
    images: 'https://www.uaito.com/UAITO.png',
  },
  twitter: {
    card: 'summary_large_image',
    title: 'UAITO - AI-Powered Engineering Automation',
    description: 'Boost productivity with AI-assisted coding and automated tasks for engineers and developers.',
    images: 'https://www.uaito.com/UAITO.png',
  },
}


export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body className={`bg-gray-100 dark:bg-gray-900 dark:text-white`}>  
        {children} 
        
      </body>
    </html>
  )
}
</file>

<file path="apps/uaito/src/components/AgentSelector.tsx">
import { SparklesIcon, ChevronDownIcon } from "@heroicons/react/24/outline";
import { LLMProvider } from "@uaito/sdk";
import { useState, useEffect } from "react";
const enabledAgents = [
    'Orquestrator',
]
const defaultAgent = enabledAgents[0]

export const AgentSelector: React.FC<{onSelected?: (value: string) => void | Promise<void>}> = ({onSelected}) => {
    const [isOpen, setIsOpen] = useState(false);
    const [selectedValue, setSelectedValue] = useState(defaultAgent);
    useEffect(() => {
      if(onSelected) {
        onSelected(selectedValue)
      }
    }, [onSelected, selectedValue])
    
    const enabled = enabledAgents.length > 1;
    return (
      <div className="relative mt-3 py-1 w-40">
        <button
          disabled={!enabled}
          onClick={() => {
            if (enabled) {
              setIsOpen(!isOpen)
            }
          }}
          className="w-full flex items-center pt-1 pb-2 pr-1 space-x-2 bg-opacity-90 bg-gray-300 dark:bg-gray-700 text-gray-900 dark:text-white font-bold rounded transition duration-300 hover:bg-gray-400 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
        >
          <SparklesIcon className="ml-2 h-5 w-5 text-blue-500" />
          <span>{selectedValue}</span>
          {
            enabled && <ChevronDownIcon className={`flex flex-end h-5 w-5 transition-transform duration-300 ${isOpen ? 'transform rotate-180' : ''}`} />
          }
        </button>
        {isOpen && (
          <div className="absolute mt-2 w-full  z-10">
            <ul className="py-1">
                {
                    enabledAgents.map((agentName, i) => {
                        return <li
                        key={`agent-${i}`}
                        className="px-4 py-2 bg-opacity-90 bg-gray-300 dark:bg-gray-700 text-gray-900 dark:text-white font-bold  transition duration-300 hover:bg-gray-400 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
                        onClick={() => {
                          setSelectedValue(agentName);
                          setIsOpen(false);
                        }}
                      >
                        {agentName}
                      </li>
                    })
                }
            </ul>
          </div>
        )}
      </div>
    );
  };
</file>

<file path="apps/uaito/src/components/AnimatedGradientText.tsx">
'use client'

import React from 'react';

interface AnimatedGradientTextProps {
  text: string;
  className?: string;
}

const AnimatedGradientText: React.FC<AnimatedGradientTextProps> = ({ text, className = '' }) => {
  return (
    <span
      className={`bg-gradient-to-r from-blue-500 via-purple-500 to-pink-500 text-transparent bg-clip-text bg-300% animate-gradient ${className}`}
    >
      {text}
    </span>
  );
};

export default AnimatedGradientText;
</file>

<file path="apps/uaito/src/components/AnimatedText.tsx">
'use client'
import React from 'react';
import { useState, useEffect } from "react";



export const AnimatedText: React.FC<{text?:string}> = (props) => {
    const [visibleLetters, setVisibleLetters] = useState(0);
    const text = props.text ?? "UAITO.io";
    const colors = [
      '#00ffff', '#00ff00', '#ffff00', '#ff8000', '#ff0000',
      '#00ccff', '#00dd00', '#ffdd00', '#ff6600', '#ff3333',
      '#0099ff', '#33cc33', '#ffcc00', '#ff4d00', '#ff6666',
      '#66ccff', '#66ff66', '#ffff66', '#ffaa66', '#ff9999'
    ];
  
    useEffect(() => {
      if (visibleLetters < text.length) {
        const timer = setTimeout(() => {
          setVisibleLetters(visibleLetters + 1);
        }, 100);
        return () => clearTimeout(timer);
      }
    }, [visibleLetters]);
  
    return (
      <span className="inline-block">
        {text.split('').map((letter, index) => (
          <span
            key={index}
            className={`font-bold transition-all duration-300 ${index < visibleLetters ? 'opacity-100' : 'opacity-0'
              }`}
            style={{
              color: colors[index % colors.length],
              textShadow: `0 0 10px ${colors[index % colors.length]}`,
            }}
          >
            {letter}
          </span>
        ))}
      </span>
    );
  };
</file>

<file path="apps/uaito/src/components/Authenticate.tsx">
import { signIn } from "next-auth/react";
import Link from 'next/link';
import Image from 'next/image';




const GoogleIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" width="24px" height="24px">
      <path fill="#FFC107" d="M43.611,20.083H42V20H24v8h11.303c-1.649,4.657-6.08,8-11.303,8c-6.627,0-12-5.373-12-12c0-6.627,5.373-12,12-12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C12.955,4,4,12.955,4,24c0,11.045,8.955,20,20,20c11.045,0,20-8.955,20-20C44,22.659,43.862,21.35,43.611,20.083z" />
      <path fill="#FF3D00" d="M6.306,14.691l6.571,4.819C14.655,15.108,18.961,12,24,12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C16.318,4,9.656,8.337,6.306,14.691z" />
      <path fill="#4CAF50" d="M24,44c5.166,0,9.86-1.977,13.409-5.192l-6.19-5.238C29.211,35.091,26.715,36,24,36c-5.202,0-9.619-3.317-11.283-7.946l-6.522,5.025C9.505,39.556,16.227,44,24,44z" />
      <path fill="#1976D2" d="M43.611,20.083H42V20H24v8h11.303c-0.792,2.237-2.231,4.166-4.087,5.571c0.001-0.001,0.002-0.001,0.003-0.002l6.19,5.238C36.971,39.205,44,34,44,24C44,22.659,43.862,21.35,43.611,20.083z" />
    </svg>
  );
  
  const LoginButton = ({ provider, children }: { provider: string; children: React.ReactNode }) => (
    <button
      onClick={() => signIn('google')}
      className="flex items-center justify-center bg-white text-gray-700 font-bold py-2 px-4 rounded-full border border-gray-300 shadow-md hover:shadow-lg transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 w-full max-w-xs"
    >
      <GoogleIcon />
      <span className="ml-3">Sign to the BETA with Google</span>
    </button>
  )
  
const Authenticate = () => {
  return (
    <section className="relative  flex flex-col items-center justify-center text-center px-4 z-10">
      <div className="max-w-5xl w-full bg-black bg-opacity-50 p-8 rounded-lg shadow-2xl">
        <h1 className="text-4xl md:text-5xl font-bold text-white mb-8 animate-fade-in-up">
          Login / Signup
        </h1>
        <div className="flex flex-col md:flex-row items-start justify-between mb-8">
          <div className="md:w-1/2 md:pr-8 text-left">
            <p className="text-xl text-purple-300 mb-4 animate-fade-in-up">
              Join UAITO and supercharge your development process!
            </p>
            <p className="text-lg text-gray-300 mb-4">
              With UAITO, you'll enjoy:
            </p>
            <ul className="list-disc list-inside text-gray-300 mb-6 space-y-2">
              <li>AI-powered code assistance</li>
              <li>Seamless project management</li>
              <li>Intelligent debugging support</li>
              <li>Automated documentation generation</li>
              <li>Cutting-edge development insights</li>
            </ul>
            <p className="text-lg text-purple-300 mb-4">
              Sign up or log in securely using your Google Account to get started!
            </p>
          </div>
          <div className="md:w-1/2 md:pl-8 flex justify-center items-center">
            <Image
              src="/UAITO.png"
              alt="UAITO"
              width={300}
              height={300}
              className="rounded-lg"
            />
          </div>
        </div>
        <div className="flex flex-col items-center space-y-4">
          <LoginButton provider="google">
            Login/Sign in with Google
          </LoginButton>
          <Link href="/" className="text-white hover:text-purple-300 transition duration-300 ease-in-out">
            Back to Homepage
          </Link>
        </div>
      </div>
    </section>
  );
}
  

  export default Authenticate
</file>

<file path="apps/uaito/src/components/Card.tsx">
import Image from 'next/image';

export const Card = ({ variant, title, description, imageUrl, name, role, company, quote }: any) => {
    switch (variant) {
      case 'project':
        return (
          <div className="bg-gray-800 rounded-lg overflow-hidden shadow-lg transition-all duration-300 hover:shadow-2xl hover:-translate-y-1">
            <Image src={imageUrl} alt={title} width={400} height={225} className="w-full h-48 object-cover" />
            <div className="p-6">
              <h3 className="text-xl font-semibold text-white mb-2">{title}</h3>
              <p className="text-gray-300">{description}</p>
            </div>
          </div>
        );
      case 'team':
        return (
          <div className="text-center">
            <Image src={imageUrl} alt={name} width={150} height={150} className="w-32 h-32 rounded-full mx-auto mb-4 object-cover" />
            <h3 className="text-lg font-semibold text-white">{name}</h3>
            <p className="text-purple-300">{role}</p>
            <p className="text-xs text-purple-300">{quote}</p>
          </div>
        );
      case 'testimonial':
        return (
          <div className="bg-gray-800 rounded-lg p-6 shadow-lg">
            <p className="text-gray-300 mb-4">"{quote}"</p>
            <p className="text-white font-semibold">{name}</p>
            <p className="text-purple-300">{company}</p>
          </div>
        );
      default:
        return null;
    }
  };
</file>

<file path="apps/uaito/src/components/ClientSideComponents.tsx">
'use client'

import React, { useEffect } from 'react';
import { ChevronDownIcon } from '@heroicons/react/24/outline';
import { ScrollToFeatures } from './Scroll';

export const AnimatedChevron: React.FC = () => (
  <div className="absolute bottom-10 left-1/2 transform -translate-x-1/2">
    <ScrollToFeatures>
      <div className="animate-bounce">
        <ChevronDownIcon className="w-10 h-10 text-purple-400" />
      </div>
    </ScrollToFeatures>
  </div>
);

export const FadeInSection: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  useEffect(() => {
    const observerOptions = {
      root: null,
      rootMargin: '0px',
      threshold: 0.1
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('fade-in-section');
        }
      });
    }, observerOptions);

    document.querySelectorAll('.fade-in').forEach(section => {
      observer.observe(section);
    });

    return () => observer.disconnect();
  }, []);

  return <>{children}</>;
};

export const ExploreButton: React.FC = () => (
  <ScrollToFeatures>
    <button className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-4 px-10 rounded-full text-lg transition-all duration-300 ease-in-out transform hover:scale-105 shadow-lg hover:shadow-purple-500/50">
      Getting Started
    </button>
  </ScrollToFeatures>
);
</file>

<file path="apps/uaito/src/components/ClientSpaceBackground.tsx">
'use client'

import React, { useEffect, useRef } from 'react';

interface Star {
  x: number;
  y: number;
  radius: number;
  speed: number;
  opacity: number;
  twinkle: boolean;
}

const ClientSpaceBackground: React.FC = () => {
  const canvasRef = useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const createStars = (count: number, speed: number): Star[] => {
      return Array.from({ length: count }, () => ({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        radius: Math.random() * 1.5 + 0.5,
        speed,
        opacity: Math.random(),
        twinkle: Math.random() > 0.7,
      }));
    };

    const starLayers = [
      createStars(100, 0.1),
      createStars(75, 0.2),
      createStars(50, 0.3),
    ];

    const drawGradient = () => {
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#000033');
      gradient.addColorStop(1, '#000066');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    };

    const drawStar = (star: Star) => {
      ctx.beginPath();
      ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
      ctx.fill();
    };

    const updateStar = (star: Star) => {
      star.y += star.speed;
      if (star.y > canvas.height) {
        star.y = 0;
      }
      if (star.twinkle) {
        star.opacity = Math.sin(Date.now() * 0.001 * star.speed) * 0.5 + 0.5;
      }
    };

    let animationFrameId: number;

    const animate = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGradient();

      starLayers.forEach((layer) => {
        layer.forEach((star) => {
          drawStar(star);
          updateStar(star);
        });
      });

      animationFrameId = requestAnimationFrame(animate);
    };

    animate();

    const handleResize = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    };

    window.addEventListener('resize', handleResize);

    return () => {
      cancelAnimationFrame(animationFrameId);
      window.removeEventListener('resize', handleResize);
    };
  }, []);

  return <canvas ref={canvasRef} className="fixed top-0 left-0 w-full h-full z-0" />;
};

export default ClientSpaceBackground;
</file>

<file path="apps/uaito/src/components/FeaturedSection.tsx">
'use client'
import {  TextBlock } from "@uaito/sdk";
import Image from 'next/image';
import { useState, useRef, useEffect, useCallback } from "react";
import { Parallax } from 'react-scroll-parallax';
import dynamic from "next/dynamic";
import { ToolComponent } from "./ToolComponent";
import { FeaturedChat, FeatureSectionProps } from "@/redux/userSlice";



const Markdown = dynamic(() => import('@/components/Markdown').then((e) => e.Markdown), {
    ssr: false,
});

// Custom hook for throttling
const useThrottle = <T extends (...args: any[]) => void>(callback: T, delay: number) => {
  const [lastCall, setLastCall] = useState(0);

  return useCallback((...args: Parameters<T>) => {
    const now = Date.now();
    if (now - lastCall >= delay) {
      callback(...args);
      setLastCall(now);
    }
  }, [callback, delay, lastCall]);
};


export const FeatureSection: React.FC<Partial<FeatureSectionProps>> = ({ title, chats, reverse = false, startScroll, speed, preview }) => {
    const [chatMessages, setChatMessages] = useState<FeaturedChat[]>(chats!.map((chat) => ({...chat, visibleContent: chat.visibleContent ?? []})));
    const sectionRef = useRef<HTMLDivElement>(null);

    const updateVisibility = useCallback((scrollPercentage: number) => {
        const totalContentLength = chatMessages.reduce((acc, msg) => {
            return acc + msg.content.reduce((contentAcc, contentItem) => {
                if (contentItem.type === "text") {
                    return contentAcc + (contentItem as TextBlock).text.length;
                }
                if (contentItem.type === "tool_result") {
                    return contentAcc + contentItem.content!.reduce((all, current) => {
                        if (current.type === "text") {
                            return all + current.text.length
                        }
                        return all + 1
                    }, 0)
                }
                return contentAcc + 1; // Count non-text blocks as 1 unit
            }, 0);
        }, 0);

        const visibleContentLength = Math.floor(totalContentLength * scrollPercentage);
        let accumulatedLength = 0;
        const updatedChatMessages = chatMessages.map(msg => {
            const visibleContent = msg.content.reduce((visibleAcc, contentItem) => {
                if (accumulatedLength >= visibleContentLength) {
                    return visibleAcc;
                }
                if (contentItem.type === "text") {
                    const textBlock = contentItem as TextBlock;
                    const remainingLength = visibleContentLength - accumulatedLength;
                    const visibleText = textBlock.text.slice(0, remainingLength);

                    accumulatedLength += visibleText.length;

                    const textLines = visibleText.split("\r\n")

                    return [...visibleAcc, ...textLines.map((text) => ({ ...textBlock, text: text }))];
                } else if (contentItem.type === "tool_result") {
                    accumulatedLength += contentItem.content!.reduce((all, current) => {
                        if (current.type === "text") {
                            return all + current.text.length
                        }
                        return all + 1
                    }, 0)

                    return [...visibleAcc, contentItem];
                    
                } else {
                    accumulatedLength += 1;
                    return [...visibleAcc, contentItem];
                }
            }, [] as FeaturedChat['content']);
            return {
                ...msg,
                visibleContent,
            };
        });

        setChatMessages(updatedChatMessages);
    }, [chatMessages]);

    const handleScroll = useThrottle(() => {
        if (sectionRef.current) {
            const sectionTop = sectionRef.current.getBoundingClientRect().top;
            const windowHeight = window.innerHeight;
            const scrollPercentage = Math.max(0, Math.min(1, 1 - sectionTop / (windowHeight-375)));
            updateVisibility(scrollPercentage);
        }
    }, 100);

    useEffect(() => {
        window.addEventListener('scroll', handleScroll);
        handleScroll(); // Initial call

        return () => window.removeEventListener('scroll', handleScroll);
    }, [handleScroll]);

    const hasContent = chatMessages.length > 0 && chatMessages.find((c) => c.visibleContent.length >0);

    return (
        <Parallax className="flex flex-grow" shouldAlwaysCompleteAnimation={true} >
            
            <div ref={sectionRef} className={`container mx-auto py-8 px-4 sm:px-6 lg:px-8 flex flex-col ${reverse ? 'lg:flex-row-reverse' : 'lg:flex-row'} items-center`}>
                <div className="w-full my-8 lg:mb-0 transform translate-y-0 will-change-transform">
                    <h2 className="font-sans font-bold text-2xl sm:text-3xl md:text-4xl lg:text-[3vw] text-white text-left mb-5">{title}</h2>
                    {hasContent ? (
                        <div className="bg-gray-100 rounded-lg p-4 w-full"> 
                            {chatMessages.map((msg, index) => (
                                (msg.visibleContent ?? []).length > 0 ? (
                                    

                                    <div key={index} className={`mt-5 flex items-start justify-start`}>
                                        {msg.role === 'assistant' &&  msg.visibleContent.length && !msg.visibleContent.some((t) => t.type.includes("tool")) && (
                                            <div className="w-6 h-6 sm:w-8 sm:h-8 rounded-full overflow-hidden flex-shrink-0 mr-2">
                                                <Image src="/UAITO.png" alt="UAITO Logo" width={32} height={32} className="object-cover w-full h-full" />
                                            </div>
                                        )}
                                       {
                                        msg.visibleContent.find((item) => item.type === "text") ? 
                                        <div className={`max-w-[calc(100%-40px)] p-3 rounded-lg ${msg.role === 'user' ? 'bg-blue-500 text-white' : 'bg-gray-300 text-gray-900'}`}>
                                        {
                                            (msg.visibleContent ?? []).map((content,  i) => {
                                                debugger;
                                                return <Markdown key={'markdown'+index+i} searchText={''}>
                                                {(content as TextBlock).text}
                                            </Markdown>
                                            })
                                        }
                                        
                                        </div> 
                                        : 

                                        (msg.visibleContent ?? []).map((content, i) => {
                                            debugger;
                                            if (content.type === "text") {
                                                return <div key={'markdown-2-'+index+i} className={`p-3 rounded-lg ${msg.role === 'user' ? 'bg-blue-500 text-white' : 'bg-gray-300 text-gray-900'}`}>
                                                    <Markdown searchText={''}>
                                                        {(content as TextBlock).text}
                                                    </Markdown>
                                                </div>
                                            }
                                            if (content.type === "tool_result"){
                                                return <ToolComponent key={'markdown-code-'+index+i}  messageId="234" {...content} />
                                            }
                                            return null
                                        })
                                       }
                                       

                                        
                                    
                                    </div>

                                  
                                ): null
                            ))}
                            {preview}
                        </div>
                    ):<div className="bg-gray-100 rounded-lg p-4 w-full">
                    <div className="flex flex-col items-center justify-center h-32">
                        <div className="animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-blue-500 mb-4">
                        <Image src="/UAITO.png" alt="UAITO Logo" width={32} height={32} className="object-cover w-full h-full" />

                        </div>
                        <p className="text-gray-600 font-medium">Agent is streaming the response</p>
                    </div>
                </div>}
                </div>
                
            </div>
            
        </Parallax>
    );
};
</file>

<file path="apps/uaito/src/components/Footer.tsx">
import Link from 'next/link';
import Script from 'next/script';

const Footer: React.FC<{}> = props => (
  <footer className="bg-gray-900 text-white py-6 z-10 relative border-t border-gray-800">
    <div className="max-w-7xl mx-auto px-4">
      <div className="flex justify-center space-x-4 mb-4">
        <Link href="/terms-and-conditions" className="text-sm text-gray-300 hover:text-white transition duration-150 ease-in-out">
          Terms and Conditions
        </Link>
        <Link href="/privacy-policy" className="text-sm text-gray-300 hover:text-white transition duration-150 ease-in-out">
          Privacy Policy
        </Link>
        <Link href="mailto:elribonazo@uaito.io" className="text-sm text-gray-300 hover:text-white transition duration-150 ease-in-out">
          Contact
        </Link>
      </div>
      <p className="text-center text-sm text-purple-400 mb-2">Empowering engineers with AI-driven solutions</p>
      <p className="text-center text-xs">&copy; 2023 UAITO.io. All rights reserved.</p>
    </div>
  <Script id="visitor-script" strategy="afterInteractive">
    {`
      (function(e,t,o,n,p,r,i){e.visitorGlobalObjectAlias=n;e[e.visitorGlobalObjectAlias]=e[e.visitorGlobalObjectAlias]||function(){(e[e.visitorGlobalObjectAlias].q=e[e.visitorGlobalObjectAlias].q||[]).push(arguments)};e[e.visitorGlobalObjectAlias].l=(new Date).getTime();r=t.createElement("script");r.src=o;r.async=true;i=t.getElementsByTagName("script")[0];i.parentNode.insertBefore(r,i)})(window,document,"https://diffuser-cdn.app-us1.com/diffuser/diffuser.js","vgo");
      vgo('setAccount', '255190599');
      vgo('setTrackByDefault', true);
      vgo('process');
    `}
  </Script>
</footer>
)

export default Footer
</file>

<file path="apps/uaito/src/components/IconCard.tsx">
export const IconCard = ({ icon: Icon, title, description, name, isFeature = true }: any) => (
    isFeature ? (
      <div className="bg-gray-900/80 rounded-lg p-6 flex flex-col items-center text-center transition-all duration-300 ease-in-out hover:shadow-xl hover:-translate-y-1 transform hover:scale-105 border border-purple-500/30">
        <Icon className="w-12 h-12 text-purple-400 mb-4" />
        <h3 className="text-xl font-bold mb-2 text-white">{title}</h3>
        <p className="text-gray-300">{description}</p>
      </div>
    ) : (
      <div className="flex flex-col items-center group">
        <div className="relative">
          <Icon className="w-12 h-12 text-purple-400 mb-2 transition-all duration-300 group-hover:text-purple-300" />
          <div className="absolute inset-0 bg-purple-500 rounded-full filter blur-md opacity-0 group-hover:opacity-50 transition-opacity duration-300"></div>
        </div>
        <span className="text-sm text-white font-semibold">{name}</span>
      </div>
    )
  );
</file>

<file path="apps/uaito/src/components/InputComponent.tsx">
import React, {
  useState,
  useRef,
  useEffect,
} from 'react';

import { useMountedApp } from '../redux/store';
import SearchBar from './SearchBar';
import { Messages } from './Messages';
import { TextBlockParam } from '@anthropic-ai/sdk/resources';
import { useSession } from 'next-auth/react';
import { LLMProvider } from '@uaito/sdk';

const InputComponent: React.FC<{agent?: string, provider?: LLMProvider}> = (props) => {
  const app = useMountedApp();
  const session = useSession();
  
  const abortControllerRef = useRef<AbortController | null>(null);
  const searchInputRef = useRef<HTMLInputElement>(null);
  const [searchText, setSearchText] = useState('');
  const [isSearchEnabled, setIsSearchEnabled] = useState(false);
  const [currentResultIndex, setCurrentResultIndex] = useState(-1);
  const currentChat = app.user
  const isLoading = currentChat?.state === "streaming";
  const messages = currentChat?.messages ?? [];
  
  const lastMessage = messages[messages.length - 1];
  const retry = lastMessage && lastMessage.role === "user" && currentChat.state !== "streaming";

  const [input, setInput] = useState(retry ? 
    (lastMessage.content[0] as TextBlockParam)?.text ?? '' :
    '');

  useEffect(() => {
    const handleScrollToNextResult = () => {
      const results = document.querySelectorAll('mark');
      if (results.length > 0) {
        setCurrentResultIndex((prevIndex) => {
          const nextIndex = (prevIndex + 1) % results.length;
          results[nextIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
          return nextIndex;
        });
      }
    };

    const fn = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        setSearchText('');
        setIsSearchEnabled(false);
      } else if (event.key === 'f' && event.metaKey) {
        event.preventDefault();
        setIsSearchEnabled(true);
        setTimeout(() => searchInputRef.current?.focus(), 0);
      } else if (event.key === 'Enter' && isSearchEnabled) {
        event.preventDefault();
        handleScrollToNextResult();
      }
    }
    window.addEventListener('keydown', fn);
    return () => {
      window.removeEventListener('keydown', fn);
    };
  }, [isSearchEnabled]);

  useEffect(() => {
    const textarea = document.querySelector('textarea');
    if (textarea) {
      textarea.style.height = 'auto';
      textarea.style.height = `${Math.min(textarea.scrollHeight, 120)}px`;
    }
  }, [input]);

  const handleTextareaKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if ((e.metaKey || e.ctrlKey) && e.key === 'a') {
      e.preventDefault();
      e.currentTarget.select();
    } else if ((e.shiftKey || e.metaKey) && e.key === 'Enter') {
      e.preventDefault();
      setInput(input + "\r\n")
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!input.trim() || isLoading) return;
    if (!session || !session.data) return 
    abortControllerRef.current = new AbortController();

    const reducedInputs = messages.reduce((all, current) => {
      if (current.type === "message") {
        const last = all[all.length-1]
        if (last && current.role === last.role) {
          return [
            ...all.slice(0, all.length-1),
            {
              role:current.role,
              content: [
                ...last.content,
                ...current.content
              ]
            }
          ]
        }
        return [...all, current];
      }
      if (current.type === "tool_use") {
        const lastMessage = all[all.length - 1];
        const updatedLastMessage = {
          ...lastMessage,
          content: [
            ...lastMessage.content,...current.content
          ]
        };
        return [...all.slice(0, -1), updatedLastMessage];
      }
      if (current.type === "tool_result") {
        return [...all, current];
      }
      return all;
    }, [] as any).map((item:any) => ({role: item.role, content: item.content}))

    app.streamMessage({
      agent:props.agent,
      prompt: input,
      inputs: reducedInputs,
      signal: abortControllerRef.current.signal,
      dispatch: app.dispatch,
      session: session.data,
      provider: props.provider
    })

    setInput('');
  };

  const handleStopRequest = () => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
  };

  if (!currentChat) {
    return <>Chat not found</>;
  }

  return (
    <div className="flex flex-col h-full rounded-lg w-full max-w-full transition-colors duration-300">
      {isSearchEnabled && <SearchBar 
        defaultValue={searchText} 
        onChange={setSearchText} 
        inputRef={searchInputRef}
      />}
      <div className="fixed bottom-0 left-0 right-0 dark:bg-gray-900 transition-colors duration-300">
        <div className="flex flex-col h-full">
          <div className="h-[calc(100vh-theme(spacing.32))] overflow-auto p-4 relative">
            <Messages searchText={searchText} messages={messages} />
          </div>
          <div className="p-4 border-t border-gray-200 bg-white dark:bg-gray-800 dark:border-gray-700">
            <form className="flex space-x-2">
              <textarea
                value={input}
                onChange={(e) => setInput(e.target.value)}
                onKeyDown={handleTextareaKeyDown}
                placeholder="Type your message..."
                className="w-full px-4 py-2 border rounded-lg text-gray-900 bg-white dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500 placeholder-gray-500 dark:placeholder-gray-400 resize-none overflow-hidden"
                style={{ height: '40px', minHeight: '40px', maxHeight: '120px' }}
                rows={1}
                disabled={isLoading && lastMessage !== undefined && lastMessage.role === "user" && currentChat.state !== "streaming"}
              />
              {
                !isLoading && input.length > 0 && <button
                type="button"
                onClick={handleSubmit} 
                className=" sm:w-auto px-6 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center transition-colors duration-200"
                disabled={isLoading}
              >
                {isLoading ? (
                  <span className="animate-spin inline-block w-4 h-4 border-2 border-white border-t-transparent rounded-full mr-2"></span>
                ) : null}

                {retry ? (isLoading ? 'Retrying...' : 'Retry') : (isLoading ? 'Sending...' : 'Send')}
              </button>
              }
              {isLoading && (
                <button
                  type="button"
                  onClick={handleStopRequest}
                  className="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 transition-colors duration-200"
                >
                  Stop
                </button>
              )}
            </form>
          </div>
        </div>
      </div>
    </div>
  );
};


export default InputComponent;
</file>

<file path="apps/uaito/src/components/KeyFeatures.tsx">
export const KeyFeatures: React.FC<{features:{title: string, description: string, icon: string}[]}> = ({features}) => (
    <div className="py-32 bg-gradient-to-br from-blue-900 via-purple-900 to-pink-900 transform translate-y-0 will-change-transform">
        <div className="container mx-auto px-8">
            <h2 className="text-5xl font-bold mb-16 text-center text-white">Key Features</h2>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-8">
                {features.map((feature, index) => (
                    <div key={index} className="feature-card bg-white bg-opacity-10 backdrop-filter backdrop-blur-lg p-6 rounded-2xl shadow-xl transition-all duration-300 hover:transform hover:scale-105 hover:bg-opacity-20">
                        <div className="text-4xl mb-4">{feature.icon}</div>
                        <h3 className="text-2xl font-bold mb-4 text-white">{feature.title}</h3>
                        <p className="text-gray-300">{feature.description}</p>
                    </div>
                ))}
            </div>
        </div>
    </div>
);
</file>

<file path="apps/uaito/src/components/Markdown.tsx">
'use client'
import React, { useState } from 'react';
import ReactMarkdown from "react-markdown";
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { oneDark } from 'react-syntax-highlighter/dist/esm/styles/prism';

const CopyButton = ({ code }) => {
  const [copied, setCopied] = useState(false);
  const handleCopy = async () => {
    await navigator.clipboard.writeText(code);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };
  return (
    <button
      onClick={handleCopy}
      className="absolute top-2 right-2 px-2 py-1 text-xs font-medium text-gray-600 bg-gray-100 rounded-md hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 dark:text-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600"
    >
      {copied ? 'Copied!' : 'Copy'}
    </button>
  );
};

export const CodeBlock = ({ searchText, node, inline, className, children, ...props }) => {
  const match = /language-(\w+)/.exec(className || '');
  const highlightedCode = String(children).replace(/\n$/, '');

  const renderComponent = (component, i) => {
    const props = component?.properties ?? {};
    const TagName = component?.tagName ?? undefined;
    const children = component?.children ?? [];
    const value = component?.value ?? '';
    if (component.type === "text") {
      const processed = processMessage(value, searchText);
      const regex = new RegExp('<mark style="background-color: yellow;">(.*?)</mark>', 'gmi');
      const parts = processed.split(regex);
      return (
        <span key={`span-${i}`} {...props}>
          {parts.map((part, index) => 
            index % 2 === 0 ? part : <mark key={`mark-${index}`} className="bg-yellow-300">{part}</mark>
          )}
        </span>
      );
    } else if (component.type === "element") {
      return <TagName key={`tag-${TagName}-${i}`} className={`${props.className?.join(" ") || ''}`} {...props}>
{children.map(renderComponent)}
        </TagName>
    }
  }

  const customRenderer = ({ rows }) => {
    return rows.map((row, index) => (
      <div key={index} className="flex">
        <span className="w-10 pr-4 text-right text-gray-500 select-none opacity-50">
          {index + 1}
        </span>
        <span className="flex-1">{renderComponent(row, index)}</span>
      </div>
    ));
  };

  const showSyntax = !inline && match !== null && match[1];
  return showSyntax ? (
    <div className="relative mt-4 mb-6">
      <CopyButton code={highlightedCode} />
      {/* @ts-ignore */}
      <SyntaxHighlighter
        language={match[1]}
        PreTag="div"
        renderer={customRenderer}
        style={oneDark}
        customStyle={{
          margin: 0,
          padding: '1rem',
          borderRadius: '0.375rem',
        }}
        codeTagProps={{
          className: 'text-sm font-mono',
        }}
        {...props}
      >
        {highlightedCode}
      </SyntaxHighlighter>
    </div>
  ) : (
    <code className={`${className} px-1 py-0.5 rounded bg-gray-300`} {...props}>
      {highlightedCode}
    </code>
  );
};

const processMessage = (message, search) => {
  if (!search.length) return message;
  const regex = new RegExp(search, 'gmi');
  return message.replace(regex, (match) => `<mark style="background-color: yellow;">${match}</mark>`);
}

export function Markdown({ children, searchText }) {
  return (
    <ReactMarkdown
      components={{
        code: (props: any) => <CodeBlock searchText={searchText} {...props} />
      }}
    >
      {children}
    </ReactMarkdown>
  );
}
</file>

<file path="apps/uaito/src/components/Messages.tsx">
import React, { useEffect, useRef } from 'react';
import { MessageState } from '../redux/userSlice';
import { Markdown } from './Markdown';
import { ToolComponent } from './ToolComponent';
import { useMountedApp } from '../redux/store';
import { TextBlock, ToolBlock, ImageBlock, DeltaBlock } from '@uaito/sdk';

export const MessageContainer = ({ id, isUser, children }) => {
    return (
        <div
            key={`msg-${id}`}
            className={`inline-block mt-4 p-3 rounded-lg w-full ${
                isUser
                    ? 'bg-blue-500 text-white shadow-md mr-auto'
                    : 'bg-white text-gray-900 shadow-md mr-auto'
            }`}
        >
            {children}
        </div>
    );
};

export const MessageItem:React.FC<{
    id: string, 
    isUser: boolean,
    content: TextBlock | ToolBlock | ImageBlock | DeltaBlock,
    searchText: string,
    type: MessageState['type']
}> = ({id, isUser, content, searchText}) => {
    const app = useMountedApp();
    if (content.type === "text") {
        return <MessageContainer id={id} isUser={isUser}>
            <Markdown searchText={searchText}>
            {content.text}
            </Markdown>
        </MessageContainer>
    } else if (content.type === "image") {
        return <img
            src={`data:${content.source.media_type};${content.source.type},${content.source.data}`}
            style={{ width: "250px", height: "auto" }}
        />
    } else if (content.type === "tool_use") {
        return <ToolComponent messageId={`msg-${id}-block`} {...content} />
    }else if (content.type === "tool_result") {
        const toolIndex = app.user.messages.findIndex((m) =>  m.type === "tool_use" &&  m.id === content.tool_use_id);

   
        const toolName = toolIndex >= 0 ?  ( app.user.messages[toolIndex] as any).name: content.name
            
        return <ToolComponent messageId={`msg-${id}-block`} {...{
            ...content,
            name: toolName
        }} />
    }
}

export const Message: React.FC<{
    message: MessageState,
    searchText: string
}> = (props) => {
    const { message, searchText } = props;
    const { id, role, content, type } = message;
    const isUser = role === 'user';
    if (Array.isArray(content)) {
        return content.filter((c) => c.type !== "error" && c.type !== "usage" ).map((currentContent, i) => {
            return <MessageItem 
            key={`msg-cmp-${message.id}-content${i}`}
            id={id} 
            isUser={isUser} 
            content={currentContent} 
            searchText={searchText}
             type={type}/>
        }
         )
    }
    //TODO: should not be needed but for some reason the message comes wrong in here
    return null
};

export const Messages: React.FC<{ searchText: string, messages: MessageState[] }> = (props) => {
    const messages: MessageState[] = props.messages;
    const messagesEndRef = useRef<HTMLDivElement>(null);

    useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }, [messages]);

    if (messages.length > 0) {
        const toolledMessages = messages.reduce<MessageState[]>((tooled, currentMessage) => {
            if (currentMessage.type === "tool_result") {

                const currentContent = currentMessage.content[0];
                if (currentContent.type === "tool_result") {
                    const tooledIndex = tooled.findIndex((tool) => tool.type === "tool_use" && tool.content[0].type === "tool_use" && tool.content[0].id === currentContent.tool_use_id) 
                    tooled[tooledIndex] = currentMessage;
                    return tooled
                }
            }
            return [...tooled, currentMessage]
        }, []);
        return (
            <>
                {toolledMessages.map((message, i) => <Message
                    key={`msg-cmp-${message.id}-${i}`}
                    message={message}
                    searchText={props.searchText}
                />)}
                <div ref={messagesEndRef} />
            </>
        );
    }

    return (
        <div className="flex-grow flex items-center justify-center mt-20">
            <p className='text-gray-700 dark:text-gray-300'>No messages yet. Start a conversation!</p>
        </div>
    );
};
</file>

<file path="apps/uaito/src/components/MobileMenu.tsx">
import { XMarkIcon } from '@heroicons/react/24/outline';
import Link from 'next/link';

export const MobileMenu = ({ isOpen, onClose, acceptedTerms }) => {
    if (!isOpen) return null;

    return (
        <div className="fixed inset-0 z-50 bg-gray-900 flex items-center justify-center">
            <div className="rounded-lg p-8 w-full max-w-md">
                <div className="flex justify-end">
                    <button onClick={onClose} className="text-gray-500 hover:text-gray-700">
                        <XMarkIcon className="h-6 w-6" />
                    </button>
                </div>
                <nav className="mt-4">
                    <ul className="space-y-4">
                        <li><Link href="#testimonials" className="text-neutral-200 hover:underline hover:text-neutral-600 block" onClick={onClose}>Testimonials</Link></li>
                        <li><Link href="#features" className="text-neutral-200 hover:underline hover:text-neutral-600 block" onClick={onClose}>Features</Link></li>
                        <li><Link href="#usecases" className="text-neutral-200 hover:underline hover:text-neutral-600 block" onClick={onClose}>Use cases</Link></li>
                        <li><Link href="#ourteam" className="text-neutral-200 hover:underline hover:text-neutral-600 block" onClick={onClose}>Our team</Link></li>
                    </ul>
                </nav>
                <div className="mt-6">
                    <Link href={"/dashboard"} className={`block w-full text-center bg-green-600 hover:bg-green-700 text-white font-bold py-4 px-10 rounded-full text-lg transition-all duration-300 ease-in-out transform hover:scale-105 shadow-lg hover:shadow-green-500/50 ${!acceptedTerms ? 'opacity-50 cursor-not-allowed' : ''}`} onClick={(e) => !acceptedTerms && e.preventDefault()}>
                        Beta access
                    </Link>
                </div>
            </div>
        </div>
    );
};
</file>

<file path="apps/uaito/src/components/ParallaxBanner.tsx">
import { BannerLayer, ParallaxBanner as ParallaxRoot } from "react-scroll-parallax";
import { AnimatedText } from "./AnimatedText";

export const ParallaxBanner: React.FC<{children?: any}>= (props) => {
    const background: BannerLayer = {
        image: "https://images.unsplash.com/photo-1451187580459-43490279c0fa?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1920&q=80",
        translateY: [0, 25],
        opacity: [1, 0.5],
        scale: [1.05, 1, "easeOutCubic"],
        shouldAlwaysCompleteAnimation: true,
        expanded: false,
        children: (
            <div className="absolute inset-0">
                <div className="w-full h-full bg-gradient-to-b from-[rgba(0,0,0,0.3)] via-[rgba(0,0,0,0.5)] to-black" />
            </div>
        )
    };

    const content: BannerLayer = {
        translateY: [0, 15],
        scale: [1, 1.05, "easeOutCubic"],
        shouldAlwaysCompleteAnimation: true,
        expanded: false,
        children: props.children ?? (
            <div className="absolute inset-0 flex flex-col items-center justify-center">
                <h1 className="font-sans font-bold text-[8vw] text-white text-center mb-5">
                    Welcome to <AnimatedText />
                </h1>
                <p className="font-sans text-[3vw] text-white opacity-80">
                    Revolutionizing daily tasks with AI powered technology
                </p>
            </div>
        )
    };

    return (
        <ParallaxRoot
            layers={[background, content]}
            className="h-screen"
        />
    );
};
</file>

<file path="apps/uaito/src/components/PricingTable.tsx">
import { useSession } from 'next-auth/react';
import React, { useEffect, useRef } from 'react';


type PricingTableProps = {
  pricingTableId: string,
  publishableKey: string,
}

const StripePricingTable: React.FC<PricingTableProps> = (props: PricingTableProps) => {
  const session = useSession()
  const tableRef = useRef(null);

  useEffect(() => {
    // Load the Stripe Pricing Table script
    const script = document.createElement('script');
    script.src = 'https://js.stripe.com/v3/pricing-table.js';
    script.async = true;
    document.body.appendChild(script);

    // Clean up function to remove the script when component unmounts
    return () => {
      document.body.removeChild(script);
    };
  }, []);

  useEffect(() => {
    if (tableRef.current) {
      const userEmail = session.data?.user?.email;

      (tableRef.current as any).setAttribute('pricing-table-id',props.pricingTableId);
      (tableRef.current as any).setAttribute('publishable-key', props.publishableKey);
      if (userEmail) {
        (tableRef.current as any).setAttribute('customer-email', userEmail)
      }
    }
  }, []);
  const AAA = 'stripe-pricing-table' as any
  return <AAA ref={tableRef}></AAA>;
};

export default StripePricingTable;
</file>

<file path="apps/uaito/src/components/Provider.tsx">
import { SparklesIcon, ChevronDownIcon } from "@heroicons/react/24/outline";
import { LLMProvider } from "@uaito/sdk";
import { useMemo, useState } from "react";
import { useAppSelector } from "@/redux/store";

const enabledProviders = [
    LLMProvider.Anthropic,
    LLMProvider.OpenAI,
    LLMProvider.HuggingFaceONNX
]

export const Provider: React.FC<{ 
  value: LLMProvider,
  onSelected: (value: LLMProvider) => void 
}> = ({ value, onSelected }) => {
  const [isOpen, setIsOpen] = useState(false);
  const downloadProgress = useAppSelector((state) => state.user.downloadProgress);

  const enabled = useMemo(() => enabledProviders.length > 1, []);

  const isDownloading = value === LLMProvider.HuggingFaceONNX && downloadProgress !== null && downloadProgress < 100;

  return (
    <div className="relative mt-3 py-1 w-48">
      <button
        disabled={!enabled || isDownloading}
        onClick={() => {
          if (enabled && !isDownloading) {
            setIsOpen(!isOpen);
          }
        }}
        className="w-full flex items-center pt-1 pb-2 pr-1 space-x-2 bg-opacity-90 bg-gray-300 dark:bg-gray-700 text-gray-900 dark:text-white font-bold rounded transition duration-300 hover:bg-gray-400 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
      >
        <SparklesIcon className="ml-2 h-5 w-5 text-purple-500" />
        <span>{value}</span>
        {enabled && (
          <ChevronDownIcon
            className={`flex flex-end h-5 w-5 transition-transform duration-300 ${isOpen ? "transform rotate-180" : ""}`}
          />
        )}
      </button>
      {isOpen && (
        <div className="absolute mt-2 w-full  z-10">
          <ul className="py-1">
            {enabledProviders.map((providerName, i) => {
              return (
                <li
                  key={`provider-${i}`}
                  className="px-4 py-2 bg-opacity-90 bg-gray-300 dark:bg-gray-700 text-gray-900 dark:text-white font-bold  transition duration-300 hover:bg-gray-400 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
                  onClick={() => {
                    onSelected(providerName as LLMProvider);
                    setIsOpen(false);
                  }}
                >
                  {providerName}
                </li>
              );
            })}
          </ul>
        </div>
      )}
    </div>
  );
};

export default Provider;
</file>

<file path="apps/uaito/src/components/Scroll.tsx">
'use client'
import React  from 'react';

export const ScrollToFeatures = ({ children }: { children: React.ReactNode }) => {
    return (
      <div onClick={() => {
        const featuresSection = document.getElementById('started');
        if (featuresSection) {
          featuresSection.scrollIntoView({ behavior: 'smooth' });
        }
      }} className="cursor-pointer">
        {children}
      </div>
    );
  };
</file>

<file path="apps/uaito/src/components/SearchBar.tsx">
import React, { useEffect, useState } from 'react'

interface SearchBarProps {
  onChange: (search: string) => void,
  defaultValue: string,
  inputRef: React.RefObject<HTMLInputElement>
}

const SearchBar: React.FC<SearchBarProps> = (props) => {
  const [isVisible, setIsVisible] = useState(false);

  useEffect(() => {
    setIsVisible(true);
  }, []);

  return (
    <div className="z-20 fixed top-20 right-0 dark:bg-gray-900 transition-colors duration-300">
      <div className="m-2">
        <input
          type="text"
          value={props.defaultValue}
          placeholder="Search..."
          onChange={(e) => props.onChange(e.target.value)}
          ref={props.inputRef}
          className={`
            w-full p-2 rounded-md
            bg-white dark:bg-gray-800
            text-gray-800 dark:text-gray-200
            border border-gray-300 dark:border-gray-600
            focus:outline-none focus:ring-2 focus:ring-blue-500
            transition-all duration-300 ease-in-out
            ${isVisible ? 'opacity-100 scale-100' : 'opacity-0 scale-95'}
          `}
          style={{ borderRadius: '4px' }}
        />
      </div>
    </div>
  );
};

export default SearchBar;
</file>

<file path="apps/uaito/src/components/SpaceBackground.tsx">
import React from 'react';
import dynamic from 'next/dynamic';

const ClientSpaceBackground = dynamic(() => import('./ClientSpaceBackground'), { ssr: false });

const SpaceBackground: React.FC = () => {
  return (
    <div className="fixed top-0 left-0 w-full h-full z-0 bg-gray-900">
      <ClientSpaceBackground />
    </div>
  );
};

export default SpaceBackground;
</file>

<file path="apps/uaito/src/components/Testimonial.tsx">
export const Testimonial = ({ quote, author, company }) => (
    <div className="testimonial-card bg-white bg-opacity-10 backdrop-filter backdrop-blur-lg p-8 rounded-2xl shadow-xl transition-all duration-300 hover:transform hover:scale-105 hover:bg-opacity-20">
        <p className="text-xl italic mb-6 text-gray-200">{quote}</p>
        <p className="font-bold text-white">{author}</p>
        <p className="text-gray-300">{company}</p>
    </div>
);


export const TestimonialSection = () => (
    <div id="testimonials" className="py-32 bg-gradient-to-br from-indigo-900 via-purple-900 to-pink-800 transform translate-y-0 will-change-transform">
        <div className="container mx-auto px-8">
            <h2 className="text-5xl font-bold mb-16 text-center text-white">What Our Users Say</h2>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
                <Testimonial
                    quote="I'm already using UAITO almost on a daily basis for simple tasks or things I don't want to remember or do anymore myself. Results really exceeded my own expectations!"
                    author="JR"
                    company="Founder of UAITO"
                />
                <Testimonial
                    quote="The level of automation and intelligence in UAITO's tools is unmatched. It's like having an entire team of experts at your fingertips."
                    author="Tony"
                    company="InnovateNow"
                />
                <Testimonial
                    quote="UAITO has been a game-changer for our projects. The AI-assisted coding and debugging features have significantly reduced our time-to-market."
                    author="Lisa Garcia"
                    company="FutureTech Solutions"
                />
            </div>
        </div>
    </div>
);
</file>

<file path="apps/uaito/src/components/TokenCounter.tsx">
import React from'react'
import { ChartBarIcon } from "@heroicons/react/24/outline";
import { useState } from "react";

const getColorForTokenCount = (count: number): string => {
    if (count < 66667) return 'bg-green-500';
    if (count < 133334) return 'bg-orange-500';
    return 'bg-red-500';
  };
  
  const formatNumber = (num: number): string => {
    return num.toLocaleString();
  };
  
export const TokenCounter: React.FC<{ input: number; output: number }> = ({ input, output }) => {
    const [isHovered, setIsHovered] = useState(false);
    const showDetailedView = isHovered || input > 66667 || output > 66667;
  
    return (
      <div 
        className="w-50 rounded-md text-sm font-semibold z-50 transition-all duration-300 pt-3"
        onMouseEnter={() => setIsHovered(true)}
        onMouseLeave={() => setIsHovered(false)}
      >
        {showDetailedView ? (
          <div className="bg-gray-200 bg-opacity-70 px-1 py-1 flex items-center justify-end space-x-2 rounded-md">
            <div className={`px-2 py-1 rounded ${getColorForTokenCount(input)}`}>
              <span className="text-white">Input: {formatNumber(input)}</span>
            </div>
            <div className={`px-2 py-1 rounded ${getColorForTokenCount(output)}`}>
              <span className="text-white">Output: {formatNumber(output)}</span>
            </div>
          </div>
        ) : (
          <div className="bg-opacity-90 bg-gray-300 space-x-2 rounded-md px-1 py-1 flex items-center space-x-2 cursor-pointer">
            <ChartBarIcon className=" h-5 w-5 text-gray-800" />
            <span className='px-2 py-1 text-gray-900'>Usage</span>
          </div>
        )}
      </div>
    );
  };
</file>

<file path="apps/uaito/src/components/ToolComponent.tsx">
import React from 'react';
import { ClockIcon, CheckCircleIcon, ExclamationCircleIcon, ChevronUpIcon, ChevronDownIcon } from "@heroicons/react/20/solid";
import { useState } from "react";
import { ToolInputDelta, ToolResultBlock, ToolUseBlock } from '@uaito/sdk';


const statusStyles = {
  started: 'text-yellow-700 bg-yellow-100 dark:text-yellow-200 dark:bg-yellow-900',
  completed: 'text-green-700 bg-green-100 dark:text-green-200 dark:bg-green-900',
  error: 'text-red-700 bg-red-100 dark:text-red-200 dark:bg-red-900'
};

const statusIcon = {
  started: <ClockIcon className="w-3 h-3 text-yellow-600 dark:text-yellow-400 animate-spin" />,
  completed: <CheckCircleIcon className="w-3 h-3 text-green-600 dark:text-green-400" />,
  error: <ExclamationCircleIcon className="w-3 h-3 text-red-600 dark:text-red-400" />
};

const ToolUseComponent: React.FC<ToolUseBlock>  = (props) => {
   const name = props.name;
   const status = 'started';
   return <div className="w-full mt-4 p-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm text-xs">
      <div className="flex items-center justify-between">
        <span className="font-medium truncate text-gray-800 dark:text-gray-200" title={`Running task ${name}`}>
          Running task {name} - {props.id}
        </span>
        <div className={`flex items-center space-x-1 px-1.5 py-0.5 rounded ${statusStyles[status] || statusStyles.error}`}>
          {statusIcon[status] || statusIcon.error}
          <span className="capitalize">{status}</span>
        </div>
      </div>
  </div>
}

const ToolOutputComponent: React.FC<ToolResultBlock  & {name: string, messageId: string}>  = (props) => {
  const name = props.name;
  const [showRaw, setShowRaw] = useState(false);
  const status = props.isError === true ? 'error' : 'completed';
  return <div className="w-full p-2 mt-4 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm text-xs">
     <div className="flex items-center justify-between">
       <span className="font-medium truncate text-gray-800 dark:text-gray-200" title={name}>
         {name} - {props.tool_use_id}
       </span>
       <div className={`flex items-center space-x-1 px-1.5 py-0.5 rounded ${statusStyles[status] || statusStyles.error}`}>
         {statusIcon[status] || statusIcon.error}
         <span className="capitalize">{status}</span>
       </div>
     </div>
     <button 
        className="mt-1 w-full px-2 py-1 text-xs font-medium text-gray-700 dark:text-gray-300 bg-gray-200 dark:bg-gray-700 rounded hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors duration-200 flex items-center justify-center"
        onClick={() => setShowRaw(!showRaw)}
      >
        {showRaw ? <ChevronUpIcon className="w-3 h-3 mr-1" /> : <ChevronDownIcon className="w-3 h-3 mr-1" />}
        {showRaw ? 'Hide' : 'Show'} Raw
      </button>
        {showRaw && (
          <pre className="mt-1 p-1 bg-gray-100 dark:bg-gray-700 rounded text-[10px] text-gray-800 dark:text-gray-200 overflow-x-auto max-h-60 border border-gray-300 dark:border-gray-600">
            {
          typeof props.content === "string" && props.content }
        {
          props.content && typeof props.content !== "string" && props.content.map((content, i) => {
            if (content.type === "text") {
              return <span key={`msg-${props.messageId}-content-${i}`}>
                {content.text}
              </span>
            }
            if (content.type === "image") {
              const raw = content.source;
              return <img 
              key={`msg-${props.messageId}-contentimg-${i}`}
                src={`data:${raw.media_type};base64,${raw.data}`} 
                style={{width:"100%"}}
              />
            }

            return null
            
          })
        }
          </pre>
        )}
 </div>
}
  
export const ToolComponent: React.FC<( ToolInputDelta | ToolUseBlock  | ToolResultBlock ) & {name: string, messageId: string}>  = (props) => {
  if (props.type === "tool_use") {
    return <ToolUseComponent {...props} />
  }
  if (props.type === "tool_result") {
    return <ToolOutputComponent {...props} />
  }
  return null;
};
</file>

<file path="apps/uaito/src/core/db.ts">
import mongoose from 'mongoose';

// Database connection function
export async function connectToDatabase(uri: string): Promise<void> {
  try {
    await mongoose.connect(uri);
    console.log('Connected to MongoDB');
  } catch (error) {
    console.error('Error connecting to MongoDB:', error);
    throw error;
  }
}

// Database disconnect function
export async function disconnectFromDatabase(): Promise<void> {
  try {
    await mongoose.disconnect();
    console.log('Disconnected from MongoDB');
  } catch (error) {
    console.error('Error disconnecting from MongoDB:', error);
    throw error;
  }
}
</file>

<file path="apps/uaito/src/core/redis.ts">
import { createClient } from 'redis';

class RedisCore {
  private client: ReturnType<typeof createClient>;

  constructor(url: string) {
    this.client = createClient({ url });
    this.client.on('error', (err) => console.error('Redis Client Error', err));
  }

  async connect(): Promise<void> {
    await this.client.connect();
  }

  async disconnect(): Promise<void> {
    await this.client.disconnect();
  }

  async subscribe(channel: string, callback: (message: string) => void): Promise<void> {
    await this.client.subscribe(channel, (message) => {
      callback(message);
    });
  }

  async publish(channel: string, message: string): Promise<number> {
    return await this.client.publish(channel, message);
  }

  async streamPublish(channel: string, message: string): Promise<string> {
    return await this.client.xAdd(channel, '*', { 'message': message });
  }

  async streamSubscribe(channel: string, callback: (message: { [key: string]: string }) => void): Promise<void> {
    let lastId = '0-0';
    while (true) {
      const response = await this.client.xRead(
        { key: channel, id: lastId },
        { COUNT: 1, BLOCK: 0 }
      );
      
      if (response && response.length > 0) {
        const [{ messages }] = response;
        if (messages.length > 0) {
          const {id, message} = messages[0];
          lastId = id;
          callback(message);
        }
      }
    }
  }
}

export default RedisCore;
</file>

<file path="apps/uaito/src/db/models/Tool.ts">
import  mongoose, { Document, Model, Schema } from 'mongoose';

export interface ITool extends Document {
    userId: string,
    threadId: string,
    name: string,
    content: string,
    input: string,
    state: string,
    error: boolean
}

const ToolSchema: Schema = new Schema({
    userId: {type: String, required: true},
    threadId: {type: String, required: true},
    content: {type: String},
    input: {type: String, required: true},
    state: {type: String, required: true},
    name: {type: String, required: true},
    error: {type: Boolean, default: false},
});

export const ToolModel: Model<ITool> = mongoose.models.Tool || mongoose.model<ITool>(
    'Tool', 
    ToolSchema
)
</file>

<file path="apps/uaito/src/db/models/Usage.ts">
import mongoose, { Schema, Document, Model } from 'mongoose';
import { IUser } from './User';

export interface IUsage extends Document {
  userId: string,
  input: number,
  output: number,
  threadId: string,
  createdAt: Date,
}

const UsageSchema: Schema = new Schema({
  userId: { type: String, required: true },
  input: { type: Number, required: true },
  output: { type: Number, required: true },
  threadId: { type: String, required: true },
  createdAt: { type: Date, default: Date.now() }
})

export const UsageModel: Model<IUsage> =
  mongoose.models.Usage ||
  mongoose.model<IUsage>('Usage', UsageSchema);

export async function createUsage(
  user: IUser,
  threadId: string,
  input?: number,
  output?: number
): Promise<IUsage> {

  const usage = await UsageModel.findOne({ threadId: threadId });
  if (usage) {
    usage.output += output ?? 0;
    usage.input += input ?? 0;
    await usage.save()
    return usage
  } else {
    const newUsage =  new UsageModel({ 
      threadId: threadId, 
      userId: user.id, 
      input: input ?? 0,
      output: output ?? 0
    })
    await newUsage.save();
    return newUsage
  }
}
</file>

<file path="apps/uaito/src/db/models/User.ts">
import mongoose, { Schema, Document, Model } from 'mongoose';
import crypto from 'crypto';

export interface IUser extends Document {
  name: string;
  email: string;
  password?: string,
  apiKey?: string,
  createdAt: Date;
}

const UserSchema: Schema = new Schema({
  name: { type: String, required: true },
  email: { type: String, required: true, unique: true },
  password: {type: String, required: false},
  apiKey: {type: String, required: false},
  createdAt: { type: Date, default: Date.now }
});

export const UserModel: Model<IUser> = mongoose.models.User || 
    mongoose.model<IUser>('User', UserSchema);

// Example function to create a user
export async function createUser(name: string, email: string, password?: string): Promise<IUser> {
  const user = new UserModel({ name, email, password });
  await user.save();
  return user
}

export async function generateApiKey(email: string) {
  const user = await UserModel.findOne({email});
  if (!user) {
    throw new Error("User not found");
  }
  user.apiKey = `uaito-sk-${crypto.randomBytes(64).toString('hex')}`;
  await user.save();
  return user.apiKey;
}

export async function getApiKey(email: string) {
  const user = await UserModel.findOne({email});
  if (!user) {
    throw new Error("User not found");
  }
  if (user.apiKey) {
    return user.apiKey;
  }
  return generateApiKey(user.email);
}

// Example function to find a user by email
export async function findUserByEmail(email: string): Promise<IUser | null> {
  return await UserModel.findOne({ email });
}
</file>

<file path="apps/uaito/src/db/index.ts">
import mongoose from 'mongoose';
import { config } from '@/config';

class DatabaseConnector {
  private static instance: DatabaseConnector;
  private isConnected: boolean = false;

  public static getInstance(): DatabaseConnector {
    if (!DatabaseConnector.instance) {
      DatabaseConnector.instance = new DatabaseConnector();
    }
    return DatabaseConnector.instance;
  }

  public async connect(): Promise<void> {
    if (this.isConnected) {
      console.log('Already connected to the database');
      return;
    }

    try {
      await mongoose.connect(config.MONGODB_URL);
      this.isConnected = true;
      console.log('Connected to the database successfully');
    } catch (error) {
      console.error('Error connecting to the database:', error);
      throw error;
    }
  }

  public async disconnect(): Promise<void> {
    if (!this.isConnected) {
      console.log('Not connected to the database');
      return;
    }

    try {
      await mongoose.disconnect();
      this.isConnected = false;
      console.log('Disconnected from the database successfully');
    } catch (error) {
      console.error('Error disconnecting from the database:', error);
      throw error;
    }
  }

}

export default new DatabaseConnector;
</file>

<file path="apps/uaito/src/hooks/useThrottle.tsx">
import { useCallback, useState } from "react";

export const useThrottle = (callback, delay) => {
    const [lastCall, setLastCall] = useState(0);
    return useCallback((...args) => {
        const now = Date.now();
        if (now - lastCall >= delay) {
            callback(...args);
            setLastCall(now);
        }
    }, [callback, delay, lastCall]);
};
</file>

<file path="apps/uaito/src/pages/api/auth/[...nextauth].ts">
import db from "@/db"
import { createUser, findUserByEmail } from "@/db/models/User"
import NextAuth from "next-auth"
import type { NextAuthOptions } from "next-auth"
import GoogleProvider from "next-auth/providers/google"

export async function ensureUserExists({email, name}:{name: string, email:string}) {
  await db.connect();
  const existingUser = await findUserByEmail(email);
  if (existingUser) {
    return existingUser;
  }
  if (process.env.ENABLE_BETA === undefined && process.env.NODE_ENV === 'production') {
    throw new Error("Beta access is now closed, sorry!")
  }
  return createUser(name, email)
}

export const authOptions: NextAuthOptions = {
  secret: 'vqUHfA39DPNWoBFVGrOtDLdRuCiJYODrYoApKdBWmPU=',
  useSecureCookies: process.env.NODE_ENV === "production",
  session: {
    strategy: "jwt",
    maxAge: 30 * 24 * 60 * 60, // 30 days
    updateAge: 24 * 60 * 60, // 24 hours
  },
  pages: {
    error: '/error'
  },
  callbacks: {
    async session({ session }) {
      if (session) {
        if (session.user && session.user.email && session.user.name) {
          await ensureUserExists({
            email: session.user.email,
            name: session.user.name
          })
        }
      }
      return session
    },
    async signIn({ user }) {
      if (!user.email) {
        throw new Error("Invalid email address");
      }
      if (!user.name) {
        throw new Error("Invalid email address");
      }
      await ensureUserExists({
        email: user.email,
        name: user.name
      })
      return true
    }
  },
  providers: [
    GoogleProvider({
      clientId: process.env.GCLIENT_ID!,
      clientSecret: process.env.GCLIENT_SECRET!,
    }),
  ],
}

export default NextAuth(authOptions)
</file>

<file path="apps/uaito/src/pages/api/download/[version].ts">
import { NextApiRequest, NextApiResponse } from 'next';
import { Octokit } from '@octokit/rest';
import fetch from 'node-fetch';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {

    try {
      if (req.method !== 'GET') {
        return res.status(405).json({ message: 'Method Not Allowed' });
      }

      const owner = process.env.GITHUB_OWNER;
      const repo = process.env.GITHUB_REPO;
      const githubToken = process.env.GITHUB_PAT;
      const version = req.query.version as string;

      if (!owner || !repo || !githubToken) {
        return res.status(500).json({ message: 'Missing required environment variables' });
      }

      const octokit = new Octokit({ auth: githubToken });

      try {
        const { data: release } = await octokit.repos.getLatestRelease({
          owner,
          repo,
        });

        const asset = release.assets.find((asset) => asset.name.includes(version))
        if (asset) {
          try {
            const response = await fetch(asset.url, {
              headers: {
                Authorization: `token ${githubToken}`,
                Accept: 'application/octet-stream'
              }
            });
            if (!response.ok) {
              throw new Error(`Failed to fetch asset: ${response.statusText}`);
            }

            res.setHeader('Content-Type', 'application/octet-stream');
            res.setHeader('Content-Disposition', `attachment; filename=${asset.name}`);
            res.setHeader('Content-Length', asset.size);

            response.body.pipe(res);
          } catch (fetchError) {
            console.error('Error fetching asset:', fetchError);
            res.status(500).json({ message: 'Error downloading GitHub release asset' });
          }
        } else {
          res.status(404).json({ message: 'GitHub release asset not found' });
        }
      } catch (error) {
        console.error('Error fetching latest GitHub release:', error);
        res.status(500).json({ message: 'Error fetching latest GitHub release' });
      }
    } catch (error) {
      console.error('Unexpected error in GitHub release asset download handler:', error);
      res.status(500).json({ message: 'An unexpected error occurred' });
    }
  }
</file>

<file path="apps/uaito/src/pages/api/tools/[threadId].ts">
import db from '@/db';
import { ToolModel } from '@/db/models/Tool';
import { getSessionUser } from '@/utils/getSessionUser';
import type { NextApiRequest, NextApiResponse } from 'next';
import NextCors from 'nextjs-cors';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  await NextCors(req, res, {
    methods: ['GET', 'HEAD', 'PUT', 'PATCH', 'POST', 'DELETE', 'OPTIONS'],
    origin: '*',
    optionsSuccessStatus: 200,
  });
  if (req.method !== 'POST' && req.method !== "GET") {
    res.setHeader('Allow', 'POST');
    return res.status(405).end('Method Not Allowed');
  }
  await db.connect()
  const currentUser = await getSessionUser(req, res)
  if (!currentUser) {
    return res.status(403).end('Invalid session or auth token');
  }
  const {threadId} = req.query;
  if (!threadId) {
    throw new Error('No threadId provided');
  }
  if (req.method === "GET") {
    const tools = await ToolModel.find({
      threadId: threadId,
      userId: currentUser.id,
      state: {
        $ne: 'completed'
      },
    });
    return res.status(200).json(tools)
  } 
  const rawBody = req.body;
  const { result,content, isError } = typeof req.body === "string" ? JSON.parse(rawBody): rawBody;
  if (!result && !content) {
    throw new Error('content json is required')
  }
  const tool = await ToolModel.findOne({
    threadId: threadId,
    userId: currentUser.id,
    state: {
      $ne: 'completed'
    }
  });
  if (tool) {
    tool.content = JSON.stringify(content || result);
    tool.state = "completed";
    tool.error = isError && isError === true ? true: false
    await tool.save()
  }
  return res.status(200).json({
    success: true
  })
}
</file>

<file path="apps/uaito/src/pages/api/key.ts">
import type { NextApiRequest, NextApiResponse } from 'next';
import { AbortController } from 'abort-controller';
import NextCors from 'nextjs-cors';
import { getServerSession } from "next-auth/next"
import {authOptions} from "./auth/[...nextauth]"
import { getApiKey } from "@/db/models/User"


export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  await NextCors(req, res, {
    methods: ['GET', 'HEAD', 'PUT', 'PATCH', 'POST', 'DELETE', 'OPTIONS'],
    origin: '*',
    optionsSuccessStatus: 200,
  });


  if (req.method !== 'GET') {
    res.setHeader('Allow', 'GET');
    return res.status(405).end('Method Not Allowed');
  }
  const session = await getServerSession(req, res, authOptions);

  if ((!session || !session.user) && req.headers['token'] !== 'elribonazo') {
    return res.status(403).end('Not Allowed');
  }

  res.writeHead(200, {
    'Content-Type': 'text/plain',
    'Transfer-Encoding': 'chunked',
    'Cache-Control': 'no-cache, no-transform',
    'Connection': 'keep-alive',
  });

  const abortController = new AbortController();

  res.on('close', () => {
    abortController.abort();
    console.log('Client disconnected, aborting stream');
  });

  try {
    const email = session?.user?.email ?? '';
    const apiKey = await getApiKey(email)
    res.json({apiKey})
} catch (error) {
    console.error("Error:", error);
    res.json({message:  (error as Error).message})
  }

}
</file>

<file path="apps/uaito/src/pages/api/webhook.ts">
import type { NextApiRequest, NextApiResponse } from 'next';
import Stripe from 'stripe';
import crypto from 'crypto';
import { createUser } from '@/db/models/User';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, { apiVersion: '2024-06-20' });

const generateSecurePassword = (length: number = 16): string => {
  return crypto.randomBytes(length).toString('hex');
};



export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method === 'POST') {
    const chunks: Uint8Array[] = [];

    for await (const chunk of req) {
      chunks.push(typeof chunk === 'string' ? Buffer.from(chunk) : chunk);
    }

    const rawBody = Buffer.concat(chunks);
    const sig = req.headers['stripe-signature'] as string;

    let event: Stripe.Event;

    try {
      event = stripe.webhooks.constructEvent(rawBody, sig, process.env.STRIPE_WEBHOOK_SECRET!);
    } catch (err: any) {
      console.error(`Webhook Error: ${err.message}`);
      return res.status(400).send(`Webhook Error: ${err.message}`);
    }

    switch (event.type) {
      case 'customer.created':
        const customer = event.data.object as Stripe.Customer;
        const username = customer.email!;
        const name = customer.name!;
        const password = generateSecurePassword();
        try {
          const newUser = await createUser(username, name, password);
          console.log('New user created:', newUser);
        } catch (error: any) {
          console.error('Error creating user:', error.message);
          return res.status(500).json({ error: 'Failed to create user' });
        }
        break;
      default:
        console.log(`Unhandled event type ${event.type}`);
    }

    // Return a response to acknowledge receipt of the event
    res.json({ received: true });
  } else {
    res.setHeader('Allow', 'POST');
    res.status(405).end('Method Not Allowed');
  }
}
</file>

<file path="apps/uaito/src/pages/_app.tsx">
import { SessionProvider } from "next-auth/react"
import { Provider } from "react-redux";

import '../app/globals.css'
import { wrapper } from "@/redux/store";

function App({
  Component,
  ...rest
}:any) {
  const { store, props } = wrapper.useWrappedStore(rest);
  return (
    <Provider store={store}>
      <SessionProvider session={props.session}>
        <Component {...props} />
      </SessionProvider>
    </Provider>
  )
}


export default App
</file>

<file path="apps/uaito/src/pages/chat.tsx">
'use client'
import 'react-toastify/dist/ReactToastify.css';

import React, { useEffect } from 'react';
import type {
  GetServerSidePropsContext,
  InferGetServerSidePropsType,
} from "next"
import { getServerSession } from "next-auth/next"
import { authOptions } from './api/auth/[...nextauth]';
import SpaceBackground from '@/components/SpaceBackground';
import dynamic from 'next/dynamic';
import { UserSession } from '@/redux/userSlice';
import { ToastContainer } from 'react-toastify';
import Stripe from 'stripe';
import { AnimatedText } from '@/components/AnimatedText';
import { TokenCounter } from '@/components/TokenCounter';
import { useMountedApp } from '@/redux/store';
import { signOut } from 'next-auth/react';
import { ArrowRightEndOnRectangleIcon, UserIcon } from '@heroicons/react/24/outline';
import Link from 'next/link';
import { useState } from 'react';
import { AgentSelector } from '@/components/AgentSelector';
import Provider from '@/components/Provider';
import { LLMProvider } from '@uaito/sdk';
import { useAppSelector } from '@/redux/store';

const InputComponent = dynamic(() => import('@/components/InputComponent'), {
  ssr: false,
});

const Chat: React.FC<InferGetServerSidePropsType<typeof getServerSideProps>> = () => {
  const app = useMountedApp();
  const [agent, setAgent] = useState<string>('orquestrator');
  const [provider, setProvider] = useState<LLMProvider | null>(null);
  const downloadProgress = useAppSelector((state) => state.user.downloadProgress);
  const isDownloading = provider === LLMProvider.HuggingFaceONNX && downloadProgress !== null && downloadProgress < 100;
  const [loaded, setLoaded] = useState(false);

  useEffect(() => {
    if (typeof window !== 'undefined') {
      const savedProvider = localStorage.getItem('uaito-selected-provider') as LLMProvider;
      if (savedProvider && Object.values(LLMProvider).includes(savedProvider)) {
        setProvider(savedProvider);
      } else {
        setProvider(LLMProvider.Anthropic);
      }
    }
  }, []);

  useEffect(() => {
    setLoaded(true);
  }, []);

  const handleProviderSelect = (selectedProvider: LLMProvider) => {
    setProvider(selectedProvider);
      localStorage.setItem('uaito-selected-provider', selectedProvider);
    
  };

  return <div className={`bg-gray-100 dark:bg-gray-900 transition-colors duration-300`}>
    <SpaceBackground />
   
      {
        loaded && <>
        <header className="shadow-sm flex h-[48px] sticky z-50 items-center justify-between">
        <h1 className="ml-5 text-2xl  font-bold font-orbitron text-transparent bg-clip-text bg-gradient-to-r from-blue-500 to-purple-500">
          <AnimatedText />
        </h1>
        <div className="flex-grow"></div>
        <div className='flex items-center space-x-3 mr-4'>
        {isDownloading && (
            <div className="flex items-center space-x-2">
              <span className="text-white text-sm">Downloading Model:</span>
              <div className="w-32 bg-gray-700 rounded-full h-2.5">
                <div className="bg-blue-600 h-2.5 rounded-full" style={{ width: `${downloadProgress}%` }}></div>
              </div>
              <span className="text-white text-sm">{downloadProgress}%</span>
            </div>
          )}
          <TokenCounter input={app.user.usage.input} output={app.user.usage.output} />
          {provider && <Provider value={provider} onSelected={handleProviderSelect} />}
          <AgentSelector onSelected={(agent) => {
            setAgent(agent.toLowerCase())
          }}/>
          <div className="pt-3 ">
            <Link
              href={"/dashboard"}
              className="bg-opacity-90 bg-gray-300 hover:bg-gray-700 text-white font-bold p-2 rounded transition duration-300 flex items-center justify-center"
            >
              <UserIcon className="text-gray-900 h-5 w-5" />
            </Link>
          </div>
          <div className="pt-3 ">
            <button
              onClick={() => signOut()}
              className="bg-red-600 hover:bg-red-700 text-white  p-2 rounded transition duration-300 flex items-center justify-center"
            >
              <ArrowRightEndOnRectangleIcon className="h-5 w-5" />
            </button>
          </div>
        </div>
      </header>
  
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        {provider && <InputComponent agent={agent} provider={provider} />}
        <ToastContainer
          autoClose={5000}
          hideProgressBar={true}
          newestOnTop={false}
          closeOnClick
          rtl={false}
          pauseOnFocusLoss
          draggable
          pauseOnHover
          theme={typeof document !== 'undefined' && document.documentElement.classList.contains('dark') ? 'dark' : 'light'}
        />
      </main>
        </>
      }
    
      
  
  </div>
};



export async function getServerSideProps(context: GetServerSidePropsContext) {
  const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
    apiVersion: '2024-06-20',
  })
  const session = await getServerSession<any, UserSession>(context.req, context.res, authOptions)
  if (!session) {
    return {
      redirect: {
        destination: "/dashboard",
        permanent: false,
      },
    }
  }
  const customers = await stripe.customers.list({
    email: session.user?.email,
    limit: 1
  })

  if (customers.data.length > 0) {
    const subscriptions = await stripe.subscriptions.list({
      customer: customers.data[0].id,
      status: 'active',
      limit: 1
    })

    if (subscriptions.data.length > 0) {
      return {
        props: {
          subscription: subscriptions.data[0]
        }
      }
    }
  }

  return {
    redirect: {
      destination: "/dashboard",
      permanent: false,
    },
  }
}

export default Chat
</file>

<file path="apps/uaito/src/pages/dashboard.tsx">
import React, { useState, useEffect, useCallback } from 'react';
import { FaApple, FaWindows } from 'react-icons/fa';
import { ComputerDesktopIcon, EyeIcon, EyeSlashIcon, WindowIcon, ArrowDownTrayIcon } from '@heroicons/react/24/outline';
import Stripe from 'stripe'
import type { GetServerSidePropsContext, InferGetServerSidePropsType } from "next"
import { getServerSession } from "next-auth/next"
import { useSession, signOut } from "next-auth/react";
import { AnimatedText } from '../components/AnimatedText';
import SpaceBackground from '../components/SpaceBackground';
import Authenticate from '@/components/Authenticate';
import { authOptions } from './api/auth/[...nextauth]';
import StripePricingTable from '@/components/PricingTable';
import Link from 'next/link';
import Footer from '@/components/Footer';
import { IUsage, UsageModel } from '../db/models/Usage';
import { UserModel } from '../db/models/User';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';
import moment from 'moment-timezone';

const Header: React.FC = () => (
  <header className="w-full text-center mb-8">
    <h1 className="text-6xl md:text-8xl font-bold font-orbitron text-transparent bg-clip-text bg-gradient-to-r from-blue-500 to-purple-500">
      <AnimatedText />
    </h1>
  </header>
);

const SubscriptionUpgrade: React.FC<{}> = () => (
  <div className="w-full max-w-4xl mx-auto bg-white rounded-lg shadow-lg p-8 mt-4">
    <h2 className="text-3xl font-bold text-gray-800 mb-4">Upgrade Your Subscription</h2>
    <p className="text-xl text-gray-600 mb-6">You still don't have any subscription and you need one to use the service!</p>
    <p className="text-lg text-gray-700 mb-6">Choose the plan that best fits your needs and start enjoying these amazing benefits today!</p>
    <StripePricingTable
      pricingTableId='prctbl_1PjkoELPQsMrIxE7LXQEx6ke'
      publishableKey='pk_test_51PgOgiLPQsMrIxE7dwh1dZnInmccnXXJ8hVisXOOf79RN4tPO1c4zV3onsCt0b6j2pqZQ4qVwv10iahAClBnTvrr00MSUAVpY2'
    />
    <p className="mt-6 text-sm text-gray-500">Need help choosing? Contact our support team for personalized assistance.</p>
  </div>
);

const WelcomeSection: React.FC<{ email: string }> = ({ email }) => (
  <div className="flex justify-between items-center mb-6">
    <h2 className="text-3xl font-bold">Welcome back, {email}!</h2>
    <button
      onClick={() => signOut()}
      className="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded text-sm transition duration-300"
    >
      Sign Out
    </button>
  </div>
);

const processHourlyData = (usage: IUsage[]) => {
  const userTimezone = moment.tz.guess();
  const today = moment().tz(userTimezone).startOf('day');
  const hourlyData = Array.from({ length: 24 }, (_, i) => ({
    hour: i,
    input: 0,
    output: 0
  }));

  usage.forEach(entry => {
    const entryDate = moment(entry.createdAt).tz(userTimezone);
    if (entryDate.isSameOrAfter(today)) {
      const hour = entryDate.hour();
      hourlyData[hour].input += entry.input;
      hourlyData[hour].output += entry.output;
    }
  });

  return hourlyData;
};

const processDailyData = (usage: IUsage[]) => {
  const userTimezone = moment.tz.guess();
  const dailyData = usage.reduce((acc, entry) => {
    const date = moment(entry.createdAt).tz(userTimezone).format('YYYY-MM-DD');
    const existingEntry = acc.find(item => item.date === date);
    if (existingEntry) {
      existingEntry.input += entry.input;
      existingEntry.output += entry.output;
    } else {
      acc.push({ date, input: entry.input, output: entry.output });
    }
    return acc;
  }, [] as { date: string; input: number; output: number }[]);

  return dailyData.sort((a, b) => moment(a.date).diff(moment(b.date)));
};

const hasMultipleDaysData = (usage: IUsage[]): boolean => {
  if (usage.length === 0) return false;
  const uniqueDays = new Set(usage.map(entry => new Date(entry.createdAt).toDateString()));
  return uniqueDays.size > 1;
};

const UsageGraph: React.FC<{ usage: IUsage[]; type: 'today' | '30d' }> = ({ usage, type }) => {
  const data = type === 'today' ? processHourlyData(usage) : processDailyData(usage);

  // Calculate totals for today
  const todayTotals = type === 'today' ? data.reduce(
    (acc, hour) => ({
      input: acc.input + hour.input,
      output: acc.output + hour.output
    }),
    { input: 0, output: 0 }
  ) : null;

  // Custom legend that includes totals for today
  const CustomLegend = ({ payload }: any) => {
    if (type !== 'today' || !todayTotals) return <Legend />;
    
    return (
      <ul className="recharts-default-legend" style={{ padding: 0, margin: 0, textAlign: 'center' }}>
        {payload.map((entry: any, index: number) => (
          <li key={`item-${index}`} style={{ display: 'inline-block', marginRight: 10 }}>
            <svg className="recharts-surface" width="14" height="14" viewBox="0 0 32 32" style={{ display: 'inline-block', verticalAlign: 'middle', marginRight: 4 }}>
              <path fill="none" stroke={entry.color} strokeWidth="4" d="M0,16h32" />
            </svg>
            <span style={{ color: entry.color }}>
              {entry.value} ({entry.dataKey === 'input' ? todayTotals.input : todayTotals.output})
            </span>
          </li>
        ))}
      </ul>
    );
  };

  const CustomTooltip = ({ active, payload, label }: any) => {
    if (active && payload && payload.length) {
      return (
        <div className="custom-tooltip bg-gray-800 p-2 rounded shadow-lg">
          <p className="label text-sm">{`Time: ${label}`}</p>
          {payload.map((pld: any) => (
            <p key={pld.dataKey} style={{ color: pld.color }} className="text-sm">
              {`${pld.name}: ${pld.value}`}
            </p>
          ))}
        </div>
      );
    }
    return null;
  };

  const ActiveDot = (props: any) => {
    const { cx, cy, stroke, dataKey } = props;
    return (
      <g>
        <circle cx={cx} cy={cy} r={4} fill={stroke} />
        <circle cx={cx} cy={cy} r={8} fill={stroke} fillOpacity={0.2} />
      </g>
    );
  };

  return (
    <ResponsiveContainer width="100%" height={300}>
      <LineChart data={data} margin={{ top: 5, right: 30, left: 20, bottom: 5 }}>
        <XAxis 
          dataKey={type === 'today' ? 'hour' : 'date'}
          tickFormatter={type === 'today' 
            ? (hour: number) => hour === 23 ? '24:00' : hour.toString().padStart(2, '0') + ':00'
            : (date) => moment(date).format('MM/DD')}
          stroke="#888"
          axisLine={{ stroke: '#888' }}
          tickLine={{ stroke: '#888' }}
        />
        <YAxis 
          stroke="#888"
          axisLine={{ stroke: '#888' }}
          tickLine={{ stroke: '#888' }}
        />
        <Tooltip 
          content={<CustomTooltip />}
          labelFormatter={type === 'today'
            ? (hour: number) => {
                const start = hour.toString().padStart(2, '0') + ':00';
                const end = hour === 23 ? '23:59' : (hour + 1).toString().padStart(2, '0') + ':00';
                return `${start} - ${end}`;
              }
            : (date) => moment(date).format('YYYY-MM-DD')}
        />
        <Legend content={<CustomLegend />} />
        <Line 
          type="monotone" 
          dataKey="input" 
          stroke="#8884d8" 
          name="Input" 
          strokeWidth={2}
          dot={false}
          activeDot={<ActiveDot />}
        />
        <Line 
          type="monotone" 
          dataKey="output" 
          stroke="#82ca9d" 
          name="Output" 
          strokeWidth={2}
          dot={false}
          activeDot={<ActiveDot />}
        />
      </LineChart>
    </ResponsiveContainer>
  );
};

const RevealableApiKey: React.FC<{  }> = () => {
  const [apiKey, setApiKey] = useState<string>('');
  const [isRevealed, setIsRevealed] = useState(false);
  const [showNotification, setShowNotification] = useState(false);

  const toggleReveal = useCallback(() => {
    fetch(`/api/key`).then((r) => r.json()).then((response) => {
      setApiKey(response.apiKey ?? '')
      setIsRevealed(!isRevealed);
    })
  }, [isRevealed]);

  const showTemporaryNotification = useCallback(() => {
    setShowNotification(true);
    setTimeout(() => setShowNotification(false), 800); // Hide after 1.5 seconds
  }, []);

  const copyToClipboard = useCallback(() => {
    navigator.clipboard.writeText(apiKey).then(() => {
      setIsRevealed(false); // Hide the input after copying
      showTemporaryNotification();
    });
  }, [apiKey, showTemporaryNotification]);

  const maskedApiKey = apiKey.replace(/./g, '•');

  return (
    <div className="relative w-full">
      <div className="flex w-full">
        <input
          type="text"
          placeholder='Click the eye icon to disclose your api key'
          readOnly
          disabled
          value={isRevealed ? apiKey : maskedApiKey}
          className="flex-grow bg-gray-700 text-white px-3 py-2 rounded-l-md"
        />
        <div className="flex">
          {isRevealed && (
            <button
              onClick={copyToClipboard}
              className="bg-gray-600 text-gray-200 px-3 py-2 text-xs transition duration-300 hover:bg-gray-500"
            >
              Copy
            </button>
          )}
          <button
            onClick={toggleReveal}
            className={`flex items-center px-3 py-2 text-gray-400 hover:text-white bg-gray-600 hover:bg-gray-500 transition duration-300 ${isRevealed ? 'rounded-r-md' : ''}`}
          >
            {isRevealed ? (
              <EyeSlashIcon className="h-5 w-5" />
            ) : (
              <EyeIcon className="h-5 w-5" />
            )}
          </button>
        </div>
      </div>
      {showNotification && (
        <div className="absolute top-full left-0 right-0 mt-2 p-2 bg-green-500 text-white text-sm rounded-md shadow-lg transition-opacity duration-300 ease-in-out opacity-100">
          API key copied to clipboard!
        </div>
      )}
    </div>
  );
};

const Dashboard: React.FC<InferGetServerSidePropsType<typeof getServerSideProps>> = (props:any) => {
  const { data: session, status } = useSession();
  const [subscription] = useState(props.pageProps.subscription);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  useEffect(() => {
    if (status === 'loading') return;
    setLoading(false);
    if (props.pageProps.error) {
      setError(props.pageProps.error);
    }
    if (props.userTimezone) {
      moment.tz.setDefault(props.userTimezone);
    }
  }, [status, props.pageProps, props.userTimezone]);

  const formatDate = (timestamp: number) => {
    return new Date(timestamp * 1000).toLocaleDateString();
  };

  if (loading) {
    return <div className="min-h-screen flex items-center justify-center bg-gray-900 text-white">
      <div className="animate-spin rounded-full h-32 w-32 border-t-2 border-b-2 border-purple-500"></div>
    </div>;
  }

  if (error) {
    return <div className="min-h-screen flex items-center justify-center bg-gray-900 text-white">
      <div className="bg-red-600 p-4 rounded-lg">
        <p className="text-xl font-bold">Error: {error}</p>
        <p>Please try again later or contact support.</p>
      </div>
    </div>;
  }

  return (
    <div className="min-h-screen flex flex-col relative bg-gray-900 text-white font-roboto">
      <SpaceBackground />
      <main className="flex-grow z-10 px-4 py-8">
        <Header />
        {session ? (
          <section className="max-w-6xl mx-auto">
            <WelcomeSection email={session.user?.email || ''} />
            <div className="space-y-6">
              {subscription ? (
               <>
                <div className="bg-gray-800 p-6 rounded-lg shadow-lg">
                  <h3 className="text-2xl font-bold mb-4">Your Subscription</h3>
                  <div className="space-y-2">
                    <p><span className="font-semibold">Plan:</span> {subscription.plan.nickname || subscription.plan.id}</p>
                    <p><span className="font-semibold">Status:</span> <span className="capitalize">{subscription.status}</span></p>
                    <p><span className="font-semibold">Current Period:</span> {formatDate(subscription.current_period_start)} - {formatDate(subscription.current_period_end)}</p>
                    <p><span className="font-semibold">Amount:</span> ${(subscription.plan.amount / 100).toFixed(2)} / {subscription.plan.interval}</p>
                  </div>
                  <div className="mt-6 grid md:grid-cols-2 gap-6">
                    <div className="bg-gray-700 p-6 rounded-lg shadow-lg">
                      <h4 className="text-xl font-bold mb-3">Start Chatting</h4>
                      <p className="text-gray-300 mb-4">
                        Begin an AI-powered conversation right in your browser. Perfect for quick queries and on-the-go access.
                      </p>
                      <Link href="/chat" className="block w-full text-center bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-4 rounded-lg text-lg transition duration-300">
                        <ComputerDesktopIcon className="inline-block w-6 h-6 mr-2" />
                        Launch Web Chat
                      </Link>
                    </div>
                    <div className="bg-gray-700 p-6 rounded-lg shadow-lg">
                      <h4 className="text-xl font-bold mb-3">Download Our Software</h4>
                      <p className="text-gray-300 mb-4">
                        Get the full UAITO experience with our desktop application. Available for macOS and Windows.
                      </p>
                      <div className="flex flex-col sm:flex-row justify-center space-y-3 sm:space-y-0 sm:space-x-4">
                        <Link 
                          href="/api/download/arm64-mac.zip" 
                          className="flex items-center justify-center bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition duration-300"
                        >
                          <FaApple className="h-6 w-6 mr-2" />
                          <span>macOS (ARM64)</span>
                        </Link>
                        <Link 
                          href="/api/download/exe" 
                          className="flex items-center justify-center bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition duration-300"
                        >
                          <FaWindows className="h-6 w-6 mr-2" />
                          <span>Windows</span>
                        </Link>
                      </div>
                    </div>
                  </div>
                </div>
                <div className="bg-gray-800 p-6 rounded-lg shadow-lg">
                  <h3 className="text-2xl font-bold mb-4">Your API Key</h3>
                  <RevealableApiKey />
                </div>
                <div className="bg-gray-800 p-6 rounded-lg shadow-lg">
                  <h3 className="text-2xl font-bold mb-4">Your Usage</h3>
                  
                  <h4 className="text-xl font-semibold mb-2">Today's Usage</h4>
                  <UsageGraph usage={props.pageProps.usage} type="today" />
                  <div className="mt-2 mb-6">
                    <p className="text-sm text-gray-400">Graph shows input and output usage grouped by hour for today.</p>
                  </div>

                  {hasMultipleDaysData(props.pageProps.usage) && (
                    <>
                      <h4 className="text-xl font-semibold mb-2">Past 30 Days</h4>
                      <UsageGraph usage={props.pageProps.usage} type="30d" />
                      <div className="mt-2">
                        <p className="text-sm text-gray-400">Graph shows input and output usage grouped by day for the past 30 days.</p>
                      </div>
                    </>
                  )}
                </div>
               </>
              ) : (
                <SubscriptionUpgrade />
              )}
            </div>
          </section>
        ) : (
          <Authenticate />
        )}
      </main>
      <Footer />
    </div>
  );
};

type UserSession = {
  user?: {
    email: string
  }
}

export async function getServerSideProps(context: GetServerSidePropsContext) {
  try {
    const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
      apiVersion: '2024-06-20',
    })
    const session = await getServerSession<any, UserSession>(context.req, context.res, authOptions)
    if (!session) {
      return  {
        props:{
          subscription: null,
          usage: [],
          userTimezone: 'UTC'
        }
      }
    }
    const customers = await stripe.customers.list({
      email: session.user?.email,
      limit: 1
    })
    let subscription:Stripe.Subscription|null = null
    if (customers.data.length > 0) {
      const subscriptions = await stripe.subscriptions.list({
        customer: customers.data[0].id,
        status: 'active',
        limit: 1
      })
      if (subscriptions.data.length > 0) {
        subscription = subscriptions.data[0]
      }
    }

    const user = await UserModel.findOne({email: session.user?.email})
    if (!user) {
      throw new Error("User not found")
    }

    const userTimezone = context.req.headers['x-timezone'] as string || 'UTC';
    
    const thirtyDaysAgo = moment().tz(userTimezone).subtract(30, 'days').toDate();

    const usage = await UsageModel.find({
      userId: user.id,
      createdAt: { $gte: thirtyDaysAgo }
    })
    .sort({ createdAt: 1 });

    const parsedUsage: IUsage[] = JSON.parse(
      JSON.stringify( 
        usage.map((u) => ({...u.toObject(), id: u.id, createdAt: moment(u.createdAt).tz(userTimezone).format()}))
      )
    );

    return {
      props: {
        subscription: subscription,
        usage: parsedUsage,
        userTimezone: userTimezone
      }
    };
  } catch (error) {
    console.error('Error fetching subscription:', error)
    return  {
      props:{
        subscription: null,
        usage: [],
        error: 'Failed to fetch subscription',
        userTimezone: 'UTC'
      }
    }
  }
}

export default Dashboard
</file>

<file path="apps/uaito/src/pages/error.tsx">
import React, { useEffect, useState } from 'react';
import Link from 'next/link';
import Image from 'next/image';
import { useRouter } from 'next/router';
import { AnimatedText } from '@/components/AnimatedText';

const ErrorPage = () => {
  const router = useRouter();
  const [errorMessage, setErrorMessage] = useState('');

  useEffect(() => {
    if (router.query.error) {
      setErrorMessage(decodeURIComponent(router.query.error as string));
    }
  }, [router.query]);

  return (
    <div className="min-h-screen bg-gray-900 flex flex-col items-center justify-center text-white">
      <nav className="fixed z-40 top-4 w-full">
        <div className="flex items-center justify-between m-auto rounded-full p-2 transition bg-gray-800 w-11/12 lg:w-auto">
          <Link href="/" className="pl-4">
            <div className="flex gap-3 items-center">
              <Image
                src="/UAITO.png"
                alt="UAITO Logo"
                width={25}
                height={25}
                className="animate-subtle-bounce"
                priority
              />
              <span className="uppercase font-bold text-white tracking-wider text-[20px] -mb-[4px]">
                <AnimatedText />
              </span>
            </div>
          </Link>
        </div>
      </nav>
      <div className="text-center px-4">
        <h1 className="text-6xl font-bold mb-4">Oops!</h1>
        <p className="text-2xl mb-8">
          {errorMessage || 'An error occurred'}
        </p>
        <div className="mb-8">
          <AnimatedText />
        </div>
        <Link href="/" className="bg-green-600 hover:bg-green-700 text-white font-bold py-4 px-10 rounded-full text-lg transition-all duration-300 ease-in-out transform hover:scale-105 shadow-lg hover:shadow-green-500/50">
          Go back to homepage
        </Link>
      </div>
    </div>
  );
};

export default ErrorPage;
</file>

<file path="apps/uaito/src/pages/index.tsx">
import React, { useEffect, useState, useCallback } from 'react';
import { ParallaxProvider } from 'react-scroll-parallax';
import { Bars3Icon } from '@heroicons/react/24/outline';
import Image from 'next/image';
import Link from 'next/link';
import { GetServerSideProps, InferGetServerSidePropsType } from 'next';
import { AnimatedText } from '@/components/AnimatedText';
import { FeatureSection } from '@/components/FeaturedSection';
import { FadeInSection } from '@/components/ClientSideComponents';
import { Card } from '@/components/Card';
import Footer from '@/components/Footer';
import { KeyFeatures } from '@/components/KeyFeatures';
import { MobileMenu } from '@/components/MobileMenu';
import { TestimonialSection } from '@/components/Testimonial';
import { ParallaxBanner } from '@/components/ParallaxBanner';
import { useThrottle } from '@/hooks/useThrottle';



const Home: React.FC<InferGetServerSidePropsType<typeof getServerSideProps>> = ({pageProps:{ features, chats }}) => {
    const [isDesktop, setIsDesktop] = useState(true);
    const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
    const acceptedTerms = true;
    const handleResize = useThrottle(() => {
        setIsDesktop(window.innerWidth >= 1024);
    }, 200);
    useEffect(() => {
        window.addEventListener('resize', handleResize);
        handleResize();
        return () => window.removeEventListener('resize', handleResize);
    }, [handleResize]);
    return (
        <ParallaxProvider>
            <style jsx>{`
                .testimonial-card {
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
                }
                .testimonial-card:hover {
                    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.6);
                }
            `}</style>
            <nav className="fixed z-40 top-4 flex h-20 w-full">
                <div className="relative flex items-center justify-between m-auto rounded-full p-2 transition bg-gray-900 w-11/12 lg:w-auto">
                    <Link href="/" className="pl-4">
                        <div className="flex gap-3 items-center">
                            <Image
                                src="/UAITO.png"
                                alt="UAITO Logo"
                                width={25}
                                height={0}
                                style={{ height: 'auto', width: '25px' }}
                                className="animate-subtle-bounce"
                                priority
                            />
                            {isDesktop && <span className="uppercase font-bold text-black tracking-wider text-[20px] -mb-[4px]">
                                <AnimatedText />
                            </span>}
                        </div>
                    </Link>
                    {isDesktop ? (
                        <>
                            <div className="hidden lg:flex px-12 gap-12">
                                <Link href="#features" className="text-neutral-200 hover:underline hover:text-neutral-600">Features</Link>
                                <Link href="#testimonials" className="text-neutral-200 hover:underline hover:text-neutral-600">Testimonials</Link>
                                <Link href="#ourteam" className="text-neutral-200 hover:underline hover:text-neutral-600">Our team</Link>
                                <Link href="#faqs" className="text-neutral-200 hover:underline hover:text-neutral-600">Faqs</Link>

                            </div>
                            <div className="hidden grow basis-0 justify-end lg:flex">
                                <Link href={"/dashboard"} className={`ml-3 bg-green-600 hover:bg-green-700 text-white font-bold py-4 px-10 rounded-full text-lg transition-all duration-300 ease-in-out transform hover:scale-105 shadow-lg hover:shadow-green-500/50 ${!acceptedTerms ? 'opacity-50 cursor-not-allowed' : ''}`} onClick={(e) => !acceptedTerms && e.preventDefault()}>
                                    Beta access
                                </Link>
                            </div>
                        </>
                    ) : (
                        <button onClick={() => setMobileMenuOpen(true)} className="lg:hidden text-neutral-200 hover:text-neutral-600">
                            <Bars3Icon className="h-6 w-6" />
                        </button>
                    )}
                </div>
            </nav>
            <MobileMenu isOpen={mobileMenuOpen} onClose={() => setMobileMenuOpen(false)} acceptedTerms={acceptedTerms} />
            <ParallaxBanner />

            <div id="features">
                <KeyFeatures features={features} />
            </div>
            <FeatureSection
                title="Examples"
                chats={chats}
            />

            <FadeInSection>
                <TestimonialSection />
            </FadeInSection>

            <FadeInSection>
                <section className="py-24 px-4 z-10 transform translate3d(0, 0, 0) fade-in">
                    <div className="max-w-7xl mx-auto">
                        <h2 className="text-5xl font-bold text-center text-white mb-16 font-orbitron">Some preview</h2>
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-10">
                            <Card
                                variant="project"
                                title="Beautifull code editor"
                                description="With support for almost all the languages, easy to read, copy and has an advanced search functionality."
                                imageUrl="/search.png"
                            />
                            <Card
                                variant="project"
                                title="Completely customizable"
                                description="Advanced and enterprise users can use their own AI tools + models."
                                imageUrl="/config.png"
                            />
                            <Card
                                variant="project"
                                title="Precise subscription invoicing"
                                description="Get through with your subscription limits or purchase higher limits to run tasks that are more complex, or longer."
                                imageUrl="/input.png"
                            />
                        </div>
                    </div>
                </section>
            </FadeInSection>

            <FadeInSection>
                <section id="ourteam" className="py-24 px-4 bg-gray-800/80 z-10 transform translate3d(0, 0, 0) fade-in">
                    <div className="max-w-7xl mx-auto">
                        <h2 className="text-5xl font-bold text-center text-white mb-16 font-orbitron">Our Team</h2>
                        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-12 justify-center">
                            <Card
                                variant="team"
                                name="JR"
                                role="Founder"
                                imageUrl="https://picsum.photos/seed/team1/150/150"
                            />

                            <Card
                                variant="team"
                                name="RM"
                                role="Founder"
                                imageUrl="https://picsum.photos/seed/team2/150/150"
                            />

                            <div className="flex flex-col items-center justify-center bg-gray-900/80 rounded-lg p-6 text-center transition-all duration-300 ease-in-out hover:shadow-xl hover:-translate-y-1 transform hover:scale-105 border border-purple-500/30">
                                <span className="text-6xl mb-4">?</span>
                                <button className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded transition duration-300 ease-in-out transform hover:-translate-y-1 hover:scale-110">
                                    Join Us
                                </button>
                            </div>
                        </div>
                    </div>
                </section>
            </FadeInSection>


            <FadeInSection>
                <section id="faqs" className="py-24 px-4 z-10 transform translate3d(0, 0, 0) fade-in">
                    <div className="max-w-7xl mx-auto">
                        <h2 className="text-5xl font-bold text-center text-white mb-16 font-orbitron">Frequently Asked Questions</h2>
                        <div className="space-y-8">
                            <div>
                                <h3 className="text-2xl font-semibold text-white mb-2">What is UAITO and how it works?</h3>
                                <p className="text-gray-300">UAITO combines AI and machine learning to offer you a feature complete AI Orquestrator through a subscription based service.</p>
                            </div>
                            <div>
                                <h3 className="text-2xl font-semibold text-white mb-2">What is an AI Orquestrator?</h3>
                                <p className="text-gray-300">
                                    An AI Orchestrator is a system or framework responsible for coordinating, managing, and integrating various AI tools, models, and components within an organization or a complex AI ecosystem. It acts as a central control mechanism that ensures different AI elements work together effectively and efficiently.
                                </p>
                            </div>
                            <div>
                                <h3 className="text-2xl font-semibold text-white mb-2">What can I build with UAITO?</h3>
                                <p className="text-gray-300">UAITO is designed to seamlessly integrate with your existing workflows. We provide plugins and APIs to ensure UAITO fits smoothly into your existing processes bringing AI and automated decision making into the pipe.</p>
                            </div>
                            <div>
                                <h3 className="text-2xl font-semibold text-white mb-2">How do I download the desktop app?</h3>
                                <p className="text-gray-300">We offer a fully capable desktop application which u can download once you login into your account, u will find more details in /dashboard page.</p>
                            </div>
                            <div>
                                <h3 className="text-2xl font-semibold text-white mb-2">Where Do I get my own UAITO API Key?</h3>
                                <p className="text-gray-300">Once you are logged into your account, u can click in the eye icon to disclose the APIKey. Then you can use that key inside your custom project or inside the Desktop application.</p>
                            </div>
                        </div>
                    </div>
                </section>
            </FadeInSection>

            <FadeInSection>

                <div className="flex items-center justify-center h-screen bg-gray-900">
                    <h1 className="font-sans font-thin text-[6vw] text-white text-center px-4">
                        Unlimited posibilities, contact us to build you a custom solution for your needs!
                    </h1>
                </div>
            </FadeInSection>

            <Footer />
        </ParallaxProvider>
    );
};

export const getServerSideProps: GetServerSideProps = async () => {
  const features = [
    { title: "AI-powered Chat", description: "Engage in intelligent conversations with our advanced AI interface", icon: "💬" },
    { title: "Automated Tasks", description: "Streamline complex engineering processes with AI assistance", icon: "🤖" },
    { title: "Desktop App", description: "Access powerful tools through our Electron-based application", icon: "💻" },
    { title: "Built-in Code Editor", description: "With easy copy-paste and advanced search functionality", icon: "📝" }
  ];

  const chats = [
    {
      visibleContent: [],
      "role": "user",
      "content": [
        {
          "type": "text",
          "text": "Search for the weather broadcast for 25th of August of 2024 till the 28th in Barcelona, Spain"
        }
      ]
    },
    {
      visibleContent: [],
      "role": "assistant",
      "content": [
        {
          "type": "text",
          "text": "Certainly! I'll use the Tavily search tool to find the weather forecast for Barcelona, Spain from August 25th to August 28th, 2024. Since this is a future date, we'll need to rely on long-term forecasts or climate averages, which may not be as accurate as short-term predictions."
        }
      ]
    },
    {
      visibleContent: [],
      "role": "user",
      "content": [
        {
          "name": "tavilySearch",
          "type": "tool_result",
          "tool_use_id": "toolu_01W5MUAs41L1gfsFF5v5Vz6V",
          "content": [
            {
              "type": "text",
              "text": `The weather forecast for Barcelona, Spain from August 25-28, 2024, indicates partly cloudy conditions with temperatures around 26-27°C during the day and 22-23°C at night. There is no significant precipitation expected during this period. The wind speed will be around 3.6-7.7 km/h. The average sea temperature in Barcelona in August is around 25.3°C.${(new Array(10).fill(' ').join(" "))}`
            },
            {
              "type": "text",
              "text": "Image https://www.barcelonayellow.com/images/stories/barcelona_weather/barcelona_weather_average_temperatures.gif\r\n"
            },
            {
              "type": "text",
              "text": "Image https://www.vickiviaja.com/wp-content/uploads/2021/04/temperatures-bcn-fahrenheit.jpg\r\n"
            },
            {
              "type": "text",
              "text": "Image https://www.wetter2.com/images/month/Barcelona-in-August.jpeg\r\n"
            },
            {
              "type": "text",
              "text": "Image https://cdn.hikb.at/charts/meteo-average-weather-weekly/barcelona-meteo-average-weather-weekly.png\r\n"
            },
            {
              "type": "text",
              "text": "Image https://www.yourweather.co.uk/wimages/foto5e472ce72bdbfed0238acb95e9f6020a.png\r\n"
            }
          ]
        }
      ]
    },
    {
      visibleContent: [],
      "role": "assistant",
      "content": [
        {
          "type": "text",
          "text": "\r\nBased on the search results, I can provide you with the following weather forecast for Barcelona, Spain from August 25th to August 28th, 2024:\r\n1. Temperature:\n   - Daytime highs: Around 26-27°C (79-81°F)\n   - Nighttime lows: Around 22-23°C (72-73°F)\r\n2. Sky conditions: Partly cloudy\r\n3. Precipitation: No significant rainfall is expected during this period.\r\n4. Wind: Light breeze with speeds around 3.6-7.7 km/h (2.2-4.8 mph)\r\n5. Sea temperature: The average sea temperature in Barcelona in August is typically around 25.3°C (77.5°F)\r\nPlease note that this forecast is based on long-term climate data and averages, as it's for a date more than a year in the future. Actual weather conditions may vary as the date approaches. It's always a good idea to check for updated forecasts closer to your travel date for more accurate information.\r\nGenerally, late August in Barcelona tends to be warm and pleasant, perfect for enjoying the city and its beaches. The weather is typically stable during this time of year, with low chances of rain and comfortable temperatures for outdoor activities."
        }
      ]
    },
    {
      visibleContent: [],
      "role": "user",
      "content": [
        {
          "type": "text",
          "text": "I want you to create a table with the data on each day individually and then store the results in a file called tiempo.txt"
        }
      ]
    },
    {
      visibleContent: [],
      "role": "assistant",
      "content": [
        {
          "type": "text",
          "text": "Certainly! I'll create a table with the weather data for each day individually from August 25th to August 28th, 2024, for Barcelona, Spain. Then, I'll store this information in a file called \"tiempo.txt\". \r\nFirst, let's create the content for the file:"
        }
      ]
    },
    {
      visibleContent: [],
      "role": "user",
      "content": [
        {
          "name": "createFile",
          "type": "tool_result",
          "isError": false,
          "tool_use_id": "toolu_011zh62X6XTxePsB8vJgQhth",
          "content": [
            {
              "type": "text",
              "text": `File created successfully!${(new Array(10).fill(' ').join(" "))}`
            }
          ]
        }
      ]
    },
    {
      visibleContent: [],
      "role": "assistant",
      "content": [
        {
          "type": "text",
          "text": "\r\nI've created a file named \"tiempo.txt\" with a table containing the weather forecast for Barcelona, Spain from August 25th to August 28th, 2024. The file has been successfully created with the following content:\r\n1. A table showing the daily forecast for each day, including:\n   - Date\n   - Day High temperature (in both Celsius and Fahrenheit)\n   - Night Low temperature (in both Celsius and Fahrenheit)\n   - Sky Conditions\n   - Wind Speed\n   - Sea Temperature (average for August)\r\n2. A note explaining that the forecast is based on long-term climate data and averages, and actual conditions may vary.\r\n3. Additional information about the expected weather conditions during this period.\r\nThe file has been saved in the current working directory. You can now access this information by opening the \"tiempo.txt\" file. If you need to make any changes or if you'd like to view the contents of the file, please let me know, and I'll be happy to help."
        }
      ]
    }
  ];

  return {
    props: {
      features,
      chats,
    },
  };
};

export default Home;
</file>

<file path="apps/uaito/src/pages/preview.tsx">
import React, { useEffect, useState } from 'react';
import { GetServerSideProps, InferGetServerSidePropsType } from 'next';
import {ParallaxBanner, ParallaxBannerLayer, ParallaxProvider } from 'react-scroll-parallax';
import ScrollyVideo from 'scrolly-video/dist/ScrollyVideo.cjs.jsx';

const Preview: React.FC<InferGetServerSidePropsType<typeof getServerSideProps>> = ({ pageProps: { chats, screenshot } }) => {
  const [scrollProgress, setScrollProgress] = useState(0);

  useEffect(() => {
    const handleScroll = () => {
      const windowHeight = window.innerHeight;
      const documentHeight = document.documentElement.scrollHeight;
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      const scrollableDistance = documentHeight - windowHeight;
      const progress = (scrollTop / scrollableDistance) * 100;
      setScrollProgress(Math.min(100, Math.max(0, progress)));
    };
    window.addEventListener('scroll', handleScroll, { passive: true });
    return () => {
      window.removeEventListener('scroll', handleScroll);
    };
  }, []);
  return (
    <div className="min-h-screen flex">
      <p className='fixed right-10 z-50 top-4'>{scrollProgress.toFixed(2)}%</p>
      <ParallaxProvider>
        
      <ParallaxBanner className="aspect-[1/1]" >

        <ParallaxBannerLayer style={{ height: '300vh' }}>
        <div className='scrolly-container' style={{ height: '300vh' }}>
          <ScrollyVideo
            src="https://scrollyvideo.js.org/goldengate.mp4"
            percentScrolled={scrollProgress}
          />
          </div>
        </ParallaxBannerLayer>

       
        <ParallaxBannerLayer 
        expanded={false}
        shouldAlwaysCompleteAnimation={true}
        translateY={[0,0]} 
        scaleX={[1,1]} 
        image='https://s3-us-west-2.amazonaws.com/s.cdpn.io/105988/banner-foreground.png'
         />

      </ParallaxBanner>


      


        

      </ParallaxProvider>
    </div>
  );
};

export const getServerSideProps: GetServerSideProps = async () => {
  return {
    props: {},
  };
};

export default Preview;
</file>

<file path="apps/uaito/src/pages/privacy-policy.tsx">
import React from 'react';
import SpaceBackground from '../components/SpaceBackground';
import Footer from '@/components/Footer';
import Link from 'next/link';
import { AnimatedText } from '@/components/AnimatedText';

const PrivacyPolicy: React.FC = () => {
  return (
    <main className="min-h-screen relative bg-gray-900 text-white font-roboto">
      <SpaceBackground />
      
      <div className="relative z-10 max-w-4xl mx-auto px-4 py-16">
        <Link href={"/"} className="block text-center p-10 text-white font-bold py-4 px-10 text-lg">
          go back to <AnimatedText />
        </Link>
        <h1 className="text-4xl font-bold mb-8 text-center">Privacy Policy</h1>
        
        <div className="space-y-6 text-lg">
          <p>Last updated: August 15, 2024</p>
          <p>This Privacy Policy describes how UAITO.io ("we", "our", or "us") collects, uses, and shares your information when you use our service. By using UAITO.io, you agree to the collection and use of your information as described in this Privacy Policy.</p>
          
          <PolicySection title="1. Information We Collect">
            <p>1.1. Personal Information: We collect your email address, name, and profile information when you create an account using Google Sign-In.</p>
            <p>1.2. Stripe: Through Stripe APIs, we access, store and manage your subscription life-cycle, billing period..</p>
            <p>1.3. Usage Data: We collect information about how you interact with UAITO.io, including chat logs and usage patterns.</p>
          </PolicySection>
          
          <PolicySection title="2. How We Use Your Information">
            <p>2.1. To provide and improve our services.</p>
            <p>2.2. To personalize your experience and offer more relevant responses.</p>
            <p>2.3. To communicate with you about your account and our services.</p>
            <p>2.4. To process payments and manage subscriptions through our payment processor, Stripe.</p>
          </PolicySection>
          
          <PolicySection title="3. Google API Services User Data Policy">
            <p>3.1. Our use and transfer of information received from Google APIs to any other app will adhere to <a href="https://developers.google.com/terms/api-services-user-data-policy" className="text-blue-400 hover:underline">Google API Services User Data Policy</a>, including the Limited Use requirements.</p>
            <p>3.2. We do not sell Google or any other third party user data or use it for advertising purposes.</p>
            <p>3.3. We do not allow humans to read Google user data unless:</p>
            <ul className="list-disc list-inside pl-5">
              <li>It is your fullname or email address</li>
            </ul>
          </PolicySection>
          
          <PolicySection title="4. Data Storage and Security">
            <p>4.1. We implement industry-standard security measures to protect your personal information.</p>
            <p>4.2. Your data, including that received from Google or Stripe APIs, is encrypted and stored securely.</p>
            <p>4.3. We retain your data for as long as necessary to provide our services and comply with legal obligations.</p>
          </PolicySection>
          
          <PolicySection title="5. Data Sharing">
            <p>5.1. We do not sell your personal information to third parties.</p>
            <p>5.2. We may share your information with service providers who help us operate our business, such as Stripe for payment processing.</p>
            <p>5.3. We may disclose your information if required by law or to protect our rights and the safety of our users.</p>
          </PolicySection>
          
          <PolicySection title="6. Your Rights and Choices">
            <p>6.1. You can access, update, or delete your personal information through your account settings.</p>
            <p>6.2. You can revoke our access to your Google data at any time through your Google Account settings or by contacting us.</p>
            <p>6.3. You have the right to request a copy of your personal data or ask for its deletion, subject to legal requirements.</p>
          </PolicySection>
          
          
          <PolicySection title="7. Changes to This Policy">
            <p>We may update this Privacy Policy from time to time. We will notify you of any significant changes via email or through our application.</p>
          </PolicySection>
          
          <PolicySection title="8. Contact Us">
            <p>If you have any questions or concerns about this Privacy Policy or our data practices, please contact us at:</p>
            <p>Email: elribonazo@uaito.io</p>
            <p>Address: C/Saragossa 78 3rd 2nd, 08006 Barcelona, Spain</p>
          </PolicySection>
          
          <p className="mt-8">This Privacy Policy is publicly accessible at https://uaito.io/privacy-policy. By using UAITO.io, you acknowledge that you have read and understood this Privacy Policy.</p>
        </div>
      </div>
      <Footer />
    </main>
  );
}

const PolicySection: React.FC<{ title: string; children: React.ReactNode }> = ({ title, children }) => (
  <section>
    <h2 className="text-2xl font-semibold mt-8 mb-4">{title}</h2>
    <div className="space-y-2">
      {children}
    </div>
  </section>
);

export default PrivacyPolicy;
</file>

<file path="apps/uaito/src/pages/terms-and-conditions.tsx">
import React from 'react';
import SpaceBackground from '../components/SpaceBackground';
import Footer from '@/components/Footer';
import Link from 'next/link';
import { AnimatedText } from '@/components/AnimatedText';

const PrivacyPolicy: React.FC = () => {
  return (
    <main className="min-h-screen relative bg-gray-900 text-white font-roboto">
      <SpaceBackground />
      
      <div className="relative z-10 max-w-4xl mx-auto px-4 py-16">
        
      <Link href={"/"} className="block text-center p-10 text-white font-bold py-4 px-10 text-lg">
      go back to <AnimatedText />
      </Link>
        <h1 className="text-4xl font-bold mb-8 text-center">Terms and Conditions</h1>
        
        <div className="space-y-6 text-lg">
          <p>Welcome to our application. By using our services, you agree to these terms and conditions.</p>
          
          <h2 className="text-2xl font-semibold mt-8 mb-4">1. Account Creation and Authentication</h2>
          <p>1.1. We use Google OAuth for account authentication. By creating an account, you agree to provide accurate and complete information.</p>
          <p>1.2. Your Google account email will be used as your primary identifier in our application.</p>
          
          <h2 className="text-2xl font-semibold mt-8 mb-4">2. Use of Personal Information</h2>
          <p>2.1. We collect and use your email address to provide and improve our services, send important notifications, and manage your account.</p>
          <p>2.2. Your email may be shared with Stripe, our payment processor, for billing and subscription management purposes.</p>
          
          <h2 className="text-2xl font-semibold mt-8 mb-4">3. Subscription and Billing</h2>
          <p>3.1. We use Stripe for managing subscriptions and processing payments.</p>
          <p>3.2. By subscribing to our services, you agree to pay all fees associated with your subscription plan.</p>
          <p>3.3. You are responsible for keeping your payment information up to date.</p>
          
          <h2 className="text-2xl font-semibold mt-8 mb-4">4. Data Protection and Privacy</h2>
          <p>4.1. We are committed to protecting your personal information and will only use it as described in our Privacy Policy.</p>
          <p>4.2. By using our services, you consent to the collection and use of your information as outlined in our Privacy Policy.</p>
          
          <h2 className="text-2xl font-semibold mt-8 mb-4">5. Termination of Services</h2>
          <p>5.1. We reserve the right to terminate or suspend your account and access to our services at our sole discretion, without notice, for conduct that we believe violates these Terms and Conditions or is harmful to other users, us, or third parties, or for any other reason.</p>
          
          <h2 className="text-2xl font-semibold mt-8 mb-4">6. Changes to Terms</h2>
          <p>6.1. We may modify these Terms and Conditions at any time. We will notify you of any significant changes via email.</p>
          
          <p className="mt-8">By using our services, you acknowledge that you have read, understood, and agree to be bound by these Terms and Conditions.</p>
        </div>
      </div>
      <Footer />

    </main>
  );
}

export default PrivacyPolicy;
</file>

<file path="apps/uaito/src/pages/thank-you.tsx">
import React from 'react';
import Image from 'next/image';

import SpaceBackground from '../components/SpaceBackground';
import Footer from '@/components/Footer';
import { AnimatedText } from '@/components/AnimatedText';

const ThankYou: React.FC = () => {
  return (
    <main className="min-h-screen relative bg-gray-900 text-white font-roboto">
      <SpaceBackground />
      <div className="relative z-10 max-w-4xl mx-auto px-4 py-16 flex flex-col items-center justify-center min-h-screen">
      <Image
        src="/UAITO.png"
        alt="UAITO"
        width={300}
        height={300}
        className="rounded-lg m-5"
      />
        <h1 className="text-4xl font-bold mb-8 text-center">Thank You for Subscribing to <AnimatedText />!</h1>
        
        <div className="space-y-6 text-lg text-center">
          <p>We're thrilled to have you on board. Your subscription has been confirmed.</p>
          <p>Get ready to explore the universe of possibilities with Uaito!</p>
        </div>

        <div className="mt-6 space-y-6 text-lg text-center">
          <p>Please check your email inbox for instructions!</p>
        </div>
        
      </div>
      <Footer />
    </main>
  );
}

export default ThankYou;
</file>

<file path="apps/uaito/src/redux/rootReducer.ts">
import { combineReducers } from 'redux';
import userReducer from './userSlice';

const rootReducer = combineReducers({
  user: userReducer,
  // Add other reducers here as needed
});

export default rootReducer;
</file>

<file path="apps/uaito/src/redux/store.ts">
import { configureStore } from '@reduxjs/toolkit'
import { createWrapper } from 'next-redux-wrapper';
import { bindActionCreators } from "redux";

import { TypedUseSelectorHook, useSelector, useDispatch } from "react-redux";

import rootReducer from './rootReducer';
import { useMemo } from 'react';
import * as actions from '../actions'

const makeStore = () => configureStore({
    reducer: rootReducer,
    devTools: process.env.NODE_ENV !== 'production',
});

export const wrapper = createWrapper(makeStore);
export type RootState = ReturnType<ReturnType<typeof makeStore>['getState']>;
export type AppDispatch = ReturnType<typeof makeStore>['dispatch'];
export const useAppSelector: TypedUseSelectorHook<RootState> =
    useSelector;

export const useMountedApp = () => {
    const dispatch = useDispatch<AppDispatch>();
    const dispatchedActions = useMemo(
        () => bindActionCreators(actions, dispatch),
        [dispatch]
    );
    const state = useAppSelector((state) => state.user);
    return {
        dispatch,
        ...{
            user: state
        },
        ...dispatchedActions,
    };
};
</file>

<file path="apps/uaito/src/redux/userSlice.tsx">
import { createSlice, PayloadAction, SerializedError } from '@reduxjs/toolkit';
import { toast } from 'react-toastify';

import { getApiKey, streamMessage } from '@/actions';
import StripePricingTable from '@/components/PricingTable';
import { Session } from 'next-auth';
import { DeltaBlock, ErrorBlock, ImageBlock, Message, TextBlock, ToolBlock, UsageBlock } from '@uaito/sdk';

export type MessageState = Message;
export type UserSession = {
  user?: {
    email: string
  }
}
export interface Feature {
    title: string;
    description: string;
    icon: string;
  }
  

export interface HomeProps {
    features: Feature[];
    chats: FeaturedChat[];
  }
export type FeaturedChat = {
  visibleContent: (ErrorBlock | TextBlock | ToolBlock | ImageBlock | DeltaBlock | UsageBlock)[],
  role: Message['role'],
  content: (ErrorBlock | TextBlock | ToolBlock | ImageBlock | DeltaBlock | UsageBlock)[]
}
export type FeatureSectionProps = {
    speed?: number,
    startScroll?: number,
    title: string,
    chats: FeaturedChat[], 
    reverse?: boolean,
    preview?: any
}
export interface ChatState {
  error: SerializedError | null,
  id: string | null,
  name: string | null,
  messages: MessageState[],
  state: 'streaming' | 'ready',
  usage: {
    apiKey: string|null,
    input: number,
    output: number
  },
  isFetchingUsageToken: boolean;
  hasFetchedUsageToken: boolean;
  downloadProgress: number | null;
}

export const initialState: ChatState = {
  error: null,
  id: null,
  name: null,
  messages: [],
  state: 'ready',
  usage: {
    apiKey: null,
    input: 0,
    output: 0
  },
  isFetchingUsageToken:false,
  hasFetchedUsageToken: false,
  downloadProgress: null,
};

export interface PushChatMessage {
  chatMessage: {
    message: Message;
    role?: 'user' | 'assistant'
  },
  session: Session
}

const userSlice = createSlice({
  name: 'user',
  initialState,
  reducers: {
    setDownloadProgress: (state, action: PayloadAction<number | null>) => {
      state.downloadProgress = action.payload;
    },
    pushChatMessage: (state, action: PayloadAction<PushChatMessage>) => {
      const { chatMessage: { message }, session } = action.payload;
      if (message.type === "error") {
        toast(
          <div>
            <p>{message.content[0].type === "error" ?
            message.content[0].message :
            'An unexpected error ocurred'} </p>
            <StripePricingTable 
            pricingTableId={'prctbl_1Po5DTLPQsMrIxE72WzZJGj7'} 
            publishableKey='pk_test_51PgOgiLPQsMrIxE7dwh1dZnInmccnXXJ8hVisXOOf79RN4tPO1c4zV3onsCt0b6j2pqZQ4qVwv10iahAClBnTvrr00MSUAVpY2'
            />
            </div>,
          { position: 'bottom-right', })
        return state
      }
      if (message.type === "usage" && message.content[0].type === "usage") {
        state.usage.input = message.content[0].input ?? 0;
        state.usage.output = message.content[0].output ?? 0;
      } else {
        const existingIndex = state.messages.findIndex((m) =>  message.id === m.id);
        if (existingIndex < 0) {
          state.messages.push(message)
        } else if (existingIndex > 0) {
          if (state.messages[existingIndex]?.chunk &&
            state.messages[existingIndex]?.content[0].type === "text") {
            state.messages[existingIndex].content[0].text += (message.content[0] as TextBlock).text
          } else {
            state.messages.push(message)
          }
        }
      }
      return state;
    },
  },
  extraReducers: (builder) => {
    builder.addCase(getApiKey.pending, (state, action) => {
      state.error = null,
      state.isFetchingUsageToken = true;
      state.hasFetchedUsageToken = false;
    })
    builder.addCase(getApiKey.rejected, (state, action) => {
      state.error = action.error;
      state.isFetchingUsageToken = false;
      state.hasFetchedUsageToken = false;
    })
    builder
      .addCase(streamMessage.pending, (state, action) => {
        state.state = "streaming"
        state.error = null;
      })
    builder
      .addCase(streamMessage.fulfilled, (state, action: PayloadAction<null>) => {
        state.state = "ready"
        state.error = null;
      })
    builder
      .addCase(streamMessage.rejected, (state, action) => {
        state.state = "ready"
        state.error = action.error
      })
  },
});

export const { pushChatMessage, setDownloadProgress } = userSlice.actions;
export default userSlice.reducer;
</file>

<file path="apps/uaito/src/utils/getSessionUser.ts">
import { getServerSession } from "next-auth";

import { IUser, UserModel } from "@/db/models/User";
import { authOptions } from "@/pages/api/auth/[...nextauth]";

export async function getSessionUser(req, res): Promise<IUser | null> {
    const session = await getServerSession(req, res, authOptions);
    if ((!session || !session.user) && !req.headers['token']) {
      return null
    }
    if (session && session.user && session.user.email) {
      return UserModel.findOne({
        email: session.user.email
      })
    }
    const apiKey = req.headers['token'];
    if (apiKey) {
      return UserModel.findOne({
        apiKey: apiKey
      })
    }
    return null
  }
</file>

<file path="apps/uaito/src/config.ts">
import { AgentTypeToOptions } from '@uaito/sdk';
import dotenv from 'dotenv';

dotenv.config();

export const safeCommands = process.env.SAFE_COMMANDS?.split(",") ?? [
    'mkdir', 'cd', 'git', 'npm', 'rm', 'for',
    'npx', 'grep', 'find', 'cp', 'ls',
]

function getModel(boost: boolean) {
  return boost ? 
  'claude-3-5-sonnet-20240620':
  'claude-3-haiku-20240307'
}

function getMaxTokens(boost: boolean) {
  return boost ? 
  8192:
  4096
}

const boost = true;
const defaultModel = getModel(boost);
const defaultMaxTokens = getMaxTokens(boost);

export const baseAgentConfig: AgentTypeToOptions[keyof AgentTypeToOptions] = {
  apiKey: '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',
  model: defaultModel,
  maxTokens: defaultMaxTokens,
  project: 'sample37651',
}

export const config = {
  STRIPE_SECRET_KEY: process.env.STRIPE_SECRET_KEY!,
  STRIPE_WEBHOOK_SECRET: process.env.STRIPE_WEBHOOK_SECRET!,
  PORT: parseInt(process.env.PORT || '3000', 10),
  REDIS_URL: process.env.REDIS_URL || 'redis://localhost:6379',
  MONGODB_URL: process.env.MONGODB_URL || 'mongodb://root:default12345@localhost:27017/admin',
};
</file>

<file path="apps/uaito/.dockerignore">
# Dependencies
node_modules
*/node_modules
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Build outputs
.next
out
build
dist

# Development files
.env.local
.env.development.local
.env.test.local
.env.production.local

# IDE files
.vscode
.idea
*.swp
*.swo

# OS files
.DS_Store
Thumbs.db

# Git
.git
.gitignore

# Documentation
*.md
!README.md

# Test files
coverage
.nyc_output
jest.config.js
__tests__
**/*.test.*
**/*.spec.*

# Misc
.dockerignore
Dockerfile*
docker-compose*
</file>

<file path="apps/uaito/.env.release">
IMAGE_NAME=uaito
REGISTRY=registry.jribo.kiwi:996/captain
</file>

<file path="apps/uaito/.eslintrc.json">
{
  "extends": "next/core-web-vitals",
  "rules": {
    "react/no-unescaped-entities": "off"
  }
}
</file>

<file path="apps/uaito/docker-compose.yml">
version: '3.8'

services:
  mongodb_uaito:
    image: mongo:latest
    container_name: mongodb_uaito
    restart: always
    environment:
      MONGO_INITDB_ROOT_USERNAME: root
      MONGO_INITDB_ROOT_PASSWORD: default12345
    ports:
      - "27017:27017"
</file>

<file path="apps/uaito/LICENSE">
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
</file>

<file path="apps/uaito/next.config.js">
/** @type {import('next').NextConfig} */
const nextConfig = {
    reactStrictMode: false,
    images: {
      unoptimized: true,
    },
    assetPrefix: '/',
    webpack: (config, { buildId, dev, isServer, defaultLoaders, webpack }) => {
        // Handle ES modules and import.meta
        config.experiments = {
            ...config.experiments,
            topLevelAwait: true,
        };

        // Handle problematic dependencies with ES modules
        config.resolve.fallback = {
            ...config.resolve.fallback,
            fs: false,
            path: false,
            crypto: false,
            stream: false,
            buffer: false,
        };

        // Configure module rules to handle ES modules properly
        config.module.rules.push({
            test: /\.m?js$/,
            type: 'javascript/auto',
            resolve: {
                fullySpecified: false,
            },
        });

        // Use webpack's DefinePlugin to replace import.meta
        config.plugins.push(
            new webpack.DefinePlugin({
                'import.meta': {
                    url: JSON.stringify('file:///')
                }
            })
        );

        return config;
    },
};

module.exports = nextConfig;
</file>

<file path="apps/uaito/postcss.config.js">
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="apps/uaito/README.md">
This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/basic-features/font-optimization) to automatically optimize and load Inter, a custom Google Font.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.
</file>

<file path="apps/uaito/release">
#!/bin/bash

# Check if .env file exists and load it
if [ -f .env.release ]; then
    echo "Loading environment variables from .env file..."
    # Load environment variables from .env file
    export $(grep -v '^#' .env.release | xargs)
else
    echo "No .env.release file found. Ensure IMAGE_NAME, REGISTRY, and NEXT_PUBLIC_ENDPOINT are set in the environment."
fi

# Check if IMAGE_NAME and REGISTRY are set
if [ -z "$IMAGE_NAME" ]; then
    echo "Error: IMAGE_NAME is not set. Please set it in .env file or as an environment variable."
    exit 1
fi

if [ -z "$REGISTRY" ]; then
    echo "Error: REGISTRY is not set. Please set it in .env file or as an environment variable."
    exit 1
fi

echo "Using IMAGE_NAME: $IMAGE_NAME"
echo "Using REGISTRY: $REGISTRY"

# Use the variables in the docker commands
DOCKER_BUILDKIT=1 docker build --platform linux/amd64 \
    -t ${IMAGE_NAME}:latest .

docker tag ${IMAGE_NAME}:latest ${REGISTRY}/${IMAGE_NAME}:latest
docker push ${REGISTRY}/${IMAGE_NAME}:latest
</file>

<file path="apps/uaito/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: 'class', // Enable dark mode
  content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      backgroundImage: {
        "gradient-radial": "radial-gradient(var(--tw-gradient-stops))",
        "gradient-conic":
          "conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))",
      },
      colors: {
        primary: {
          light: '#4da6ff',
          DEFAULT: '#0066cc',
          dark: '#004080',
        },
        secondary: {
          light: '#ff6b6b',
          DEFAULT: '#ee5253',
          dark: '#c23a3a',
        },
      },
      fontFamily: {
        inter: ['Inter', 'sans-serif'],
        sans: ['Inter', 'ui-sans-serif', 'system-ui', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'Helvetica Neue', 'Arial', 'Noto Sans', 'sans-serif'],
        serif: ['Merriweather', 'ui-serif', 'Georgia', 'Cambria', 'Times New Roman', 'Times', 'serif'],
        mono: ['Fira Code', 'ui-monospace', 'SFMono-Regular', 'Menlo', 'Monaco', 'Consolas', 'Liberation Mono', 'Courier New', 'monospace'],
      },
      fontSize: {
        'xs': ['0.75rem', { lineHeight: '1rem' }],
        'sm': ['0.875rem', { lineHeight: '1.25rem' }],
        'base': ['1rem', { lineHeight: '1.5rem' }],
        'lg': ['1.125rem', { lineHeight: '1.75rem' }],
        'xl': ['1.25rem', { lineHeight: '1.75rem' }],
        '2xl': ['1.5rem', { lineHeight: '2rem' }],
        '3xl': ['1.875rem', { lineHeight: '2.25rem' }],
        '4xl': ['2.25rem', { lineHeight: '2.5rem' }],
        '5xl': ['3rem', { lineHeight: '1' }],
      },
      spacing: {
        '128': '32rem',
        '144': '36rem',
      },
      borderRadius: {
        '4xl': '2rem',
      },
      boxShadow: {
        'inner-lg': 'inset 0 2px 4px 0 rgba(0, 0, 0, 0.06)',
      },
    },
  },
  plugins: [

  ],
}
</file>

<file path="apps/uaito/tsconfig.json">
{
  "compilerOptions": {
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": false,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "commonjs",
    "target": "ES2020",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./src/*"
      ]
    },
    "strictNullChecks": true
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}
</file>

<file path="packages/sdk/src/llm/huggingface/llama/constants.ts">
export const START_TEXT_TAG = '<|begin_of_text|>';



export const START_HEADER_TAG = '<|start_header_id|>';
export const END_HEADER_TAG = '<|end_header_id|>';

export const TOOL_TAG = '<|python_tag|>';
export const END_TAG = '<|eot_id|>';
export const END_MSG = '<|eom_id|>';

export const THINKING_TAG = '<|thinking|>';
export const ANSWER_TAG = '<|answer|>';
</file>

<file path="packages/sdk/src/llm/huggingface/stopCriteria.ts">
import {
  InterruptableStoppingCriteria,
  PreTrainedTokenizer
} from "@huggingface/transformers";


import { Message } from "../../types";
import { END_HEADER_TAG, END_TAG, START_HEADER_TAG, START_TEXT_TAG } from "./llama/constants";






export class StopCriteria extends InterruptableStoppingCriteria {
  private reason: Message | null = null;


  constructor(
    private tokenizer: PreTrainedTokenizer,
  ) {
    super();
  }

  public setReason(reason: Message | null) {
    this.reason = reason
  }

  public getReason() {
    return this.reason
  }

  private parse(json: string): any {
    try {
      return JSON.parse(json);
    } catch (error) {
      return json;
    }
  }

  private clean(text: string): string {
    return text.replace(END_TAG, "")
      .replace(START_TEXT_TAG, "")
      .replace(START_HEADER_TAG, "")
      .replace(END_HEADER_TAG, "")
      .replace(END_TAG, "")
  }

  public override _call(sections: number[][], scores: any): any[] {
    return sections.map((s, i) => {
      const currentDecoded = this.tokenizer.decode(s);
      console.log(currentDecoded)
        let active: boolean = false;
        const parsedMessage = s.reduce<string[]>((text, i) => {
          const decodedI = this.tokenizer.decode([i]);
          // if (decodedI.includes(START_TOOL_TAG)) {
          //   active = true;
          //   return [];
          // } else if (decodedI.includes(END_TOOL_TAG)) {
          //   active = false
          //   return [];
          // }
          // if (active) {
          //   return [...text, this.clean(decodedI)];
          // }
          return text;
        }, [])
        if (parsedMessage.length > 0) {
          const body = this.parse(parsedMessage.join(""));
          if (typeof body !== 'string') {
            const id = `tool-${i}`;
            const message: Message = {
              id,
              role: 'assistant',
              type: 'tool_use',
              content: [{
                ...body,
                id,
                input: body.parameters ?? {},
                type: 'tool_use'
              }]
            }
            if (!currentDecoded.includes(`Output for tool${id}`)) {
              this.setReason(message);
              return true;
            } 
          }
    
      }
      return false;
    })
  }
}
</file>

<file path="packages/sdk/src/llm/huggingface/types.ts">
import { Tensor } from "@huggingface/transformers";

export type TensorDataType = {
    input_ids: Tensor;
    attention_mask: Tensor;
    token_type_ids?: Tensor;
}
</file>

<file path="packages/sdk/src/llm/huggingface/utils.ts">
interface ParsedCall {
    name: string;
    positionalArgs: unknown[];
    keywordArgs: Record<string, unknown>;
  }

export function parseArguments(argsString: string): string[] {
    const args: string[] = [];
    let current = "";
    let inQuotes = false;
    let quoteChar = "";
    let pDepth = 0; 
    let bDepth = 0; 

    for (let i = 0; i < argsString.length; i++) {
      const char = argsString[i];

      if (!inQuotes && (char === '"' || char === "'")) {
        inQuotes = true;
        quoteChar = char;
        current += char;
      } else if (inQuotes && char === quoteChar) {
        inQuotes = false;
        quoteChar = "";
        current += char;
      } else if (!inQuotes && char === "(") {
        pDepth++;
        current += char;
      } else if (!inQuotes && char === ")") {
        pDepth--;
        current += char;
      } else if (!inQuotes && char === "{") {
        bDepth++;
        current += char;
      } else if (!inQuotes && char === "}") {
        bDepth--;
        current += char;
      } else if (!inQuotes && char === "," && pDepth === 0 && bDepth === 0) {
        args.push(current.trim());
        current = "";
      } else {
        current += char;
      }
    }

    if (current.trim()) {
      args.push(current.trim());
    }

    return args;
  };

  export function extractPythonicCalls(toolCallContent: string): string[] {
    try {
      const cleanContent = toolCallContent.trim();

      try {
        const parsed = JSON.parse(cleanContent);
        if (Array.isArray(parsed)) {
          return parsed;
        }
      } catch {
        // Fallback to manual parsing
      }

      if (cleanContent.startsWith("[") && cleanContent.endsWith("]")) {
        const inner = cleanContent.slice(1, -1).trim();
        if (!inner) return [];
        return parseArguments(inner).map((call) =>
          call.trim().replace(/^['"]|['"]$/g, ""),
        );
      }

      return [cleanContent];
    } catch (error) {
      console.error("Error parsing tool calls:", error);
      return [];
    }
  };

  export function  parsePythonicCall(command: string): ParsedCall | null {
    try {
      const parsed = JSON.parse(command);
      if (Array.isArray(parsed)) {
        return parsed.map((call) => this.parsePythonicCall(call)) as any;
      }
      return {
        ...parsed,
        positionalArgs:[],
        keywordArgs: parsed.arguments
      };
    } catch {
      const callMatch = command.match(/^([a-zA-Z0-9_]+)\((.*)\)$/s);
      if (!callMatch) return null;
  
      const [, name, argsStr] = callMatch;
      const args = parseArguments(argsStr);
      const positionalArgs: unknown[] = [];
      const keywordArgs: Record<string, unknown> = {};
  
      for (const arg of args) {
        const kwargMatch = arg.match(/^([a-zA-Z0-9_]+)\s*=\s*(.*)$/s);
        if (kwargMatch) {
          const [, key, value] = kwargMatch;
          try {
            keywordArgs[key] = JSON.parse(value);
          } catch {
            keywordArgs[key] = value;
          }
        } else {
          try {
            positionalArgs.push(JSON.parse(arg));
          } catch {
            positionalArgs.push(arg);
          }
        }
      }
      return { name, positionalArgs, keywordArgs };
    }

  };


  export function mapArgsToNamedParams(  paramNames: string[],  positionalArgs: unknown[], keywordArgs: Record<string, unknown>): Record<string, unknown> {
    const namedParams: Record<string, unknown> = {};
    positionalArgs.forEach((arg, idx) => {
      if (idx < paramNames.length) {
        namedParams[paramNames[idx]] = arg;
      }
    });
    Object.assign(namedParams, keywordArgs);
    return namedParams;
  };
</file>

<file path="packages/sdk/src/llm/Openai.ts">
import OpenAIAPI from 'openai';
import { v4 } from 'uuid';
import { BaseLLM } from "./Base";
import {
  LLMProvider,
  OpenAIOptions,
  Message,
  MessageInput,
  ToolUseBlock,
  OnTool,
  DeltaBlock,
  TextBlock,
  BaseLLMCache,
  ReadableStreamWithAsyncIterable
} from "../types";
import {
  ChatCompletionContentPart,
  ChatCompletionContentPartText,
  ChatCompletionContentPartImage,
  ChatCompletionMessageParam,
  ChatCompletionToolMessageParam,
  FunctionDefinition,
  ChatCompletionAssistantMessageParam,
} from 'openai/resources';
import { ToolInputDelta } from '../types';
import { Stream } from 'openai/streaming';
import { MessageArray } from '..';


/**
 * A more complete implementation of the OpenAI-based LLM,
 * mirroring the structure and patterns found in the Anthropic class.
 */
export class OpenAI extends BaseLLM<LLMProvider.OpenAI, OpenAIOptions> {
  private onTool?: OnTool;
  private openai: OpenAIAPI;
  public inputs: MessageArray<MessageInput> = new MessageArray();

  public cache: BaseLLMCache = { toolInput: null, chunks: '', tokens: { input: 0, output: 0 } }

  constructor(
    { options }: { options: OpenAIOptions },
    onTool?: OnTool
  ) {
    super(LLMProvider.OpenAI, options);
    this.onTool = onTool;

    // Initialize the OpenAI client
    this.openai = new OpenAIAPI({
      apiKey: options.apiKey,
    });
  }

  /**
   * Return max tokens or a default (e.g. 4096).
   */
  get maxTokens() {
    return this.options.maxTokens ?? 4096;
  }

  private fromInputToParam(model: MessageInput): ChatCompletionMessageParam {
    const content: Array<ChatCompletionContentPart> = [];
    const filteredContent = model.content
      .filter((c) =>
        c.type !== "tool_delta" &&
        c.type !== "usage" &&
        c.type !== "delta" &&
        c.type !== "error"
      );

    const messageParam: ChatCompletionMessageParam = {
      role: model.role as any,
      content:[],
    };

    for (const c of filteredContent) {

      if (c.type === "text") {
        const textBlock: ChatCompletionContentPartText = {
          type: 'text',
          text: c.text,
        };
        content.push(textBlock);
      } else if (c.type === "image") {
        const imageBlock: ChatCompletionContentPartImage = {
          type: 'image_url',
          image_url: {
            url: c.source.data,
          },
        };
        content.push(imageBlock);
      } else if (c.type === "tool_result") {
        const toolContent = (c.content ?? []).map((inner) => {
          if (inner.type === "text") {
            return <ChatCompletionContentPartText>{
              type: 'text',
              text: inner.text,
            };
          }
          return {
            type: 'text',
            text: `[Unhandled content type: ${inner.type}]`,
          } as ChatCompletionContentPartText;
        });

        content.push(...toolContent);


        (messageParam as unknown as ChatCompletionToolMessageParam).tool_call_id = c.tool_use_id;
        (messageParam as unknown as ChatCompletionToolMessageParam).role = "tool";

      } else if (c.type === "tool_use") {
        (messageParam as ChatCompletionAssistantMessageParam).tool_calls = [
          {
            id: c.id!,
            type: "function",
            function: {
              name: c.name!,
              arguments:JSON.stringify(c.input),
            }
          }
        ]
        messageParam.content = null
      }
    }

    if (messageParam.content !== null) {
      messageParam.content = content;
    }

    return messageParam;
  }

  get tools() {
    return this.options.tools?.map((tool) => {
      const parsedTool = JSON.parse(JSON.stringify(tool));
      const functionDefinition: FunctionDefinition = {
        name: parsedTool.name,
        description: parsedTool.description,
        parameters: parsedTool.input_schema
      }
      return {
        type: "function" as const,
        function: functionDefinition
      }
    })
  }


  get llmInputs() {
    return this.inputs
    .flatMap((input) => this.fromInputToParam(input))
    .filter((c) => {
      if (Array.isArray(c.content) && c.content.length === 0) {
        return false;
      }
      return true;
    })
  }

   async performTaskStream(
    prompt: string,
    chainOfThought: string,
    system: string,
  ): Promise<ReadableStreamWithAsyncIterable<Message>> {

    this.inputs = this.includeLastPrompt(prompt, chainOfThought, this.inputs);
    
    const tools = this.tools && this.tools.length > 0 ? this.tools : undefined;

    let request: OpenAIAPI.Chat.ChatCompletionCreateParams = {
      model: this.options.model,
      messages: [
        {
          role: "system",
          content: system,
        },
        ...this.llmInputs,
      ],
      max_tokens: this.maxTokens,
      stream: true,
      tools
    };

    // Try to preserve usage if we have it
    this.cache.tokens.input = 0;
    this.cache.tokens.output = 0;

    const createStream = async (params: OpenAIAPI.Chat.ChatCompletionCreateParams) => {
      return this.retryApiCall(async () => {
        const stream = await this.openai.chat.completions.create(params) as Stream<OpenAIAPI.Chat.Completions.ChatCompletionChunk>;
        return stream.toReadableStream() as ReadableStreamWithAsyncIterable<OpenAIAPI.Chat.Completions.ChatCompletionChunk>
      });
    };

    const stream = await createStream(request);
    const transform = await this.transformStream<
      OpenAIAPI.Chat.Completions.ChatCompletionChunk, 
      Message
    >(
      stream,
      this.chunk.bind(this)
    );

    // auto-mode logic
    const automodeStream = await this.transformAutoMode(
      transform,
      async () => {
        const newStream = await createStream({
          ...request,
          messages: [
            {
              role: "system",
              content: system,
            },
            ...this.llmInputs
          ],
          stream: true,
        });
        return this.transformStream<OpenAIAPI.Chat.Completions.ChatCompletionChunk, Message>(
          newStream,
          this.chunk.bind(this)
        );
      },
      this.onTool?.bind(this)
    );

    return automodeStream;
  }

   async performTaskNonStream(
    prompt: string,
    chainOfThought: string,
    system: string,
  ): Promise<Message> {
    this.inputs.push(...this.includeLastPrompt(prompt, chainOfThought, this.inputs))
    this.cache.tokens.input = 0;
    this.cache.tokens.output = 0;
    let sdkMessage: Message;
    const tools = this.tools && this.tools.length > 0 ? this.tools : undefined;

    while(true) {
      const request: OpenAIAPI.Chat.ChatCompletionCreateParams = {
        model: this.options.model,
        messages: [
          {
            role: "system",
            content: system,
          },
          ...this.inputs.map(this.fromInputToParam),
        ],
        max_tokens: this.maxTokens,
        tools
      };
      const response = await this.openai.chat.completions.create(request);
      this.cache.tokens.input = response.usage?.prompt_tokens ?? this.cache.tokens.input;
      this.cache.tokens.output = response.usage?.completion_tokens ?? this.cache.tokens.output;
      const [{ finish_reason, message }] = response.choices;
      let role = message?.role || "assistant";
      let content = message?.content || "";
      if (finish_reason === "tool_calls") {
        const toolCall = message?.tool_calls?.[0];
        if (toolCall &&
          this.onTool &&
          this.tools?.find((t) => t.function.name === toolCall.function.name)) {
          const toolInputBlock: ToolUseBlock = {
            type: 'tool_use',
            input: toolCall.function.arguments,
            name: toolCall.function.name,
            id: toolCall.id,
          }
          sdkMessage = {
            id: v4(),
            role: role,
            type: 'tool_use',
            content: [toolInputBlock]
          }
          this.inputs.push(sdkMessage)

          await this.onTool?.bind(this)(sdkMessage, this.options.signal);
        }
      } else if (finish_reason === "stop") {
        const textBlock: TextBlock = {
          type: 'text',
          text: content
        }
        sdkMessage = {
          id: v4(),
          role: role,
          type: 'message',
          content: [textBlock]
        }
        this.inputs.push(sdkMessage)

        break;
      } else if (finish_reason === "length" || finish_reason === "content_filter") {
        const textBlock: TextBlock = {
          type: "text",
          text: content
        };
        sdkMessage = {
          id: v4(),
          role,
          type: "message",
          content: [textBlock]
        };
        this.inputs.push(sdkMessage)

        break;
      } else {
        const fallbackBlock: TextBlock = {
          type: 'text',
          text: content
        };
        sdkMessage = {
          id: v4(),
          role,
          type: 'message',
          content: [fallbackBlock]
        };
        this.inputs.push(sdkMessage)

        break;
      }
    }
    return {
      id: sdkMessage!.id,
      role: sdkMessage!.role,
      type: "message",
      content: sdkMessage!.content
    };
  }


  private chunk(
    chunk: OpenAIAPI.Chat.Completions.ChatCompletionChunk,
  ): Message | null {
    if (chunk.object !== "chat.completion.chunk") {
      return null;
    }
    const [choice] = chunk.choices;
    if (!choice) {
      return null;
    }

    const delta = choice.delta;
    //Tools
    if (delta && delta.tool_calls) {
      const toolCall = delta.tool_calls[0];
      const args = !toolCall.function || toolCall.function.arguments === ""
        ? "{}"
        : (toolCall.function.arguments ?? "{}");

      if (toolCall.function?.name) {
        const tool_delta: ToolInputDelta = {
          id: toolCall.id!,
          name: toolCall.function?.name,
          type: 'tool_delta',
          partial: args,
        };
        this.cache.toolInput = tool_delta;
        const message:Message =  {
          id: chunk.id,
          role: 'assistant',
          type: 'tool_delta',
          content: [tool_delta]
        };
        return message;
      }
    }

    const finishReason = choice.finish_reason;

    if (finishReason === "tool_calls") {
      const deltaBlock = this.cache.toolInput! as ToolInputDelta;
      const toolUseBlock: ToolUseBlock = {
        id: deltaBlock.id!,
        name: deltaBlock.name!,
        input: JSON.parse(deltaBlock.partial),
        type: 'tool_use'
      }
      const message:Message =  {
        id: chunk.id,
        role: 'assistant',
        type: 'tool_use',
        content: [toolUseBlock]
      };
      return message;
    }

    if (finishReason === "stop" || finishReason === "length") {
      const deltaBlock: DeltaBlock = {
        type: 'delta',
        // "stop_reason" can be "stop", "length", etc.
        // For simplicity, just set it to "end_turn" if "stop".
        stop_reason: finishReason === "stop"
          ? "end_turn"
          : "max_tokens",
        stop_sequence: null
      };
      const message:Message =  {
        id: chunk.id,
        role: 'assistant',
        type: 'delta',
        content: [deltaBlock]
      };
      return message;
    }

    // 3) Check if there's partial text content
    if (choice.delta?.content) {
      const textBlock: TextBlock = {
        type: 'text',
        text: choice.delta.content
      };
      const message:Message =  {
        id: chunk.id,
        role: 'assistant',
        type: 'message',
        chunk: true,
        content: [textBlock]
      };
      return message;
    }

    return null;
  }
}
</file>

<file path="packages/sdk/src/cli.ts">
#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';

import { LLMProvider, BinConfig, OnTool, Tool } from './types';
import { Agent } from './agents/index';
import { MessageArray } from './utils';




// Add a command named "run" (you can rename it). 
// The command loads a configuration file specified via --config or defaults to uaito.config.json.
yargs(hideBin(process.argv))
    .command(
        'run <message>',
        'Runs the application with a given configuration',
        (yargs) => {
            return yargs
                .positional('message', {
                    type: 'string',
                    describe: 'Message to send to the agent',
                })
                .option('config', {
                    alias: 'c',
                    type: 'string',
                    default: 'uaito.config.js',
                    describe: 'Path to a configuration file. Defaults to [cwd]/uaito.config.js',
                })
                .option('agent', {
                    alias: 'a',
                    type: 'string',
                    describe: 'Agent name to load specific config (uaito.[agent].js)',
                })
                .option('verbose', {
                    alias: 'v',
                    type: 'boolean',
                    default: false,
                    describe: 'Show detailed log output',
                })
                .option('stream', {
                    alias: 's',
                    type: 'boolean',
                    default: false,
                    describe: 'Use streaming mode',
                });
        },
        async (argv) => {
            // Capture the message from the positional argument
            if (!argv.message) {
                console.error('You need to specify a message');
                process.exit(1);
            }
            const message = argv.message;
            
            // Determine config file path based on agent option
            const configFileName = argv.agent 
                ? `uaito.${argv.agent}.js`
                : 'uaito.config.js';
            
            const configPath = path.resolve(process.cwd(), configFileName);
            let fileContents: BinConfig<LLMProvider> = (await import(configPath)).default;

            try {
                const onTool = fileContents?.onTool;
                const tools = fileContents?.tools;
                const createSystemPrompt = fileContents?.createSystemPrompt;
                const chainOfThought = fileContents?.chainOfThought ??  `Answer the user's request using relevant tools only if the tool exists and is relevant. 
                Before calling a tool, do some internal analysis. 
                1. First, determine if you have access to the requested tool.
                2. Second, think about which of the provided tools is the relevant tool to answer the user's request. 
                3. Third, go through each of the required parameters of the relevant tool and determine if the user has directly provided or given enough information to infer a value. 
                When deciding if the parameter can be inferred, carefully consider all the context to see if it supports a specific value.
                If all of the required parawmeters are present or can be reasonably inferred, close the thinking tag and proceed with the tool call. 
                BUT, if one of the values for a required parameter is missing, 
                DO NOT invoke the function (not even with fillers for the missing params) and instead, ask the user to provide the missing parameters. 
                DO NOT ask for more information on optional parameters if it is not provided.
                DO NOT reflect on the quality of the returned search results in your response.`;


                // Check if config file exists
                if (!fs.existsSync(configPath)) {
                    console.error(`Configuration file not found at: ${configPath}`);
                    console.error(argv.agent
                        ? `Please create a config file named uaito.${argv.agent}.js`
                        : 'Please create a config file or specify one using the --config option');
                    process.exit(1);
                }
                if (argv.verbose) {
                    console.log('Raw configuration file contents:\n', fileContents);
                }


                const agent = new Agent(
                    fileContents.provider,
                    fileContents.options,
                    onTool,
                    MessageArray.from([]),
                    tools
                );

                const useStream = argv.stream ? true: undefined;
                const {response} = await agent.performTask(
                    message,
                    chainOfThought,
                    createSystemPrompt ? createSystemPrompt(tools ?? []) : '',
                    useStream 
                );

                if (useStream) {
                    for await (const chunk of response) {
                        agent.log(`Stream response: ${chunk.type}: ${JSON.stringify(chunk, null, 2)}`);
                    }
                } else {
                    agent.log(`Final response: ${JSON.stringify(response, null, 2)}`);
                }
                
            } catch (error) {
                console.error('Error:', error);
                process.exit(1);
            }
        }
    )
    .demandCommand(1, 'You need to specify a command')
    .strict()
    .help()
    .argv;
</file>

<file path="packages/sdk/src/config.ts">
export const ANSI_RED = '\x1b[31m';
export const ANSI_GREEN = '\x1b[32m';
export const ANSI_GRAY = '\x1b[90m';
export const ANSI_BLUE = '\x1b[34m';
export const ANSI_RESET = '\x1b[0m';
export const ANSI_YELLOW = '\x1b[33m';
</file>

<file path="packages/sdk/src/index.ts">
export * from './types'
export * from './config';
export * from './agents/index';
export * from './llm/Base';
export * from './utils'
</file>

<file path="packages/sdk/src/utils.ts">
import { v4 } from "uuid";
import { Message, MessageInput, Role } from "./types";

function isValidRole(role: any): role is Role {
  return role === 'assistant' || role === 'user' || role === 'system' || role === 'ipython';
}

function isValidMessageContent(content: any): boolean {
  if (typeof content !== 'object' || content === null) {
    return false;
  }
  switch (content.type) {
    case 'text':
      return typeof content.text === 'string';
    case 'image':
      return typeof content.source === 'object' 
        && typeof content.source.data === 'string'
        && ['image/jpeg', 'image/png', 'image/gif', 'image/webp'].includes(content.source.media_type)
        && content.source.type === 'base64';
    case 'tool_start':
    case 'tool_use':
      return typeof content.id === 'string'
        && typeof content.name === 'string'
        && content.input !== undefined;
    case 'tool_delta':
      return typeof content.partial === 'string';
    case 'tool_result':
      return typeof content.tool_use_id === 'string'
        && (Array.isArray(content.content) || content.content === undefined)
        && (typeof content.isError === 'boolean' || content.isError === undefined);
    case 'delta':
      return ['end_turn', 'max_tokens', 'stop_sequence', 'tool_use', null].includes(content.stop_reason)
        && (typeof content.stop_sequence === 'string' || content.stop_sequence === null);
    case 'usage':
      return (typeof content.input === 'number' || content.input === undefined)
        && (typeof content.output === 'number' || content.output === undefined);
    case 'error':
      return typeof content.message === 'string';
    default:
      return false;
  }
}

function validateMessageInput(item: any): item is MessageInput {
  const contentValid = item.content.every(isValidMessageContent);
  if (!item.id) {
    item.id = v4();
  }
  return item.role !== undefined &&
    item.content !== undefined && 
    isValidRole(item.role) && 
    contentValid;
}

export class MessageArray<T extends MessageInput> extends Array<T> {

  static from(items: MessageInput[]): MessageArray<MessageInput> {
    return new MessageArray(items);
  }

  constructor(items: T[] = []) {
    super(...(Array.isArray(items) ? items : [items]));
    return new Proxy(this, {
      get: (target: typeof this, prop:string | symbol, receiver: any) => {
        if (prop === 'push') {
          return  (...items: T[] | T[][]): number => {
            for (const item of items) {
              if (Array.isArray(item)) {
                for (const im of item) {
                  if (validateMessageInput(im)) {
                    const lastOne = target[target.length - 1];
                    if (this.isSameRole(lastOne, im)) {
                      if (Array.isArray(lastOne.content) && Array.isArray(im.content)) {
                        Array.prototype.push.call(lastOne.content, ...im.content);
                      } else {
                        Array.prototype.push.call(target, im);
                      }
                    } else {
                      Array.prototype.push.call(target, im);
                    }
                  } else {
                    debugger;
                    console.error('Invalid Array message input, skipping:', im);
                  }
                }
              } else {
                if (validateMessageInput(item)) {
                  const lastOne = target[target.length - 1];
                  if (this.isSameRole(lastOne, item)) {
                    if (Array.isArray(lastOne.content) && Array.isArray(item.content)) {
                      Array.prototype.push.call(lastOne.content, ...item.content);
                    } else {
                      Array.prototype.push.call(target, item);
                    }
                  } else {
                    Array.prototype.push.call(target, item);
                  }
                } else {
                  debugger;
                  console.error('Invalid message input, skipping:', item);
                }
              }
            }
            return target.length;
          };
        }
        return Reflect.get(target, prop, receiver);
      }
    });
  }

  protected isSameRole(lastOne: T, item: T): boolean {
    const isTool = item.content.some((c) => c.type === 'tool_result');
    return lastOne?.role === item.role && item.role === "user" && !isTool;
  }
}
</file>

<file path="packages/sdk/tsup/tsup.cjs.ts">
import createConfig from '@trust0/ridb-build';

export default createConfig({
  format:[ 'cjs'],
  entry: ['src/index.ts'],
});
</file>

<file path="packages/sdk/tsup/tsup.esm.ts">
import createConfig from '@trust0/ridb-build';

export default createConfig({
  format:[ 'esm'],
  entry: ['src/index.ts'],
});
</file>

<file path="packages/sdk/build.sh">
#!/usr/bin/env bash
set -e  # Exit on any error
rm -rf build
npx tsup --config tsup/tsup.esm.ts
npx tsup --config tsup/tsup.cjs.ts
npx tsup --config tsup/tsup.cjs.ts --dts-only
</file>

<file path="packages/sdk/tsconfig.json">
{
    "compilerOptions": {
      "lib": [
        "dom",
        "dom.iterable",
        "esnext"
      ],
      "allowJs": true,
      "skipLibCheck": true,
      "strict": false,
      "noEmit": false,
      "outDir": "build",
      "declaration":true,
      "esModuleInterop": true,
      "module": "ESNext",
      "target": "es2020",
      "moduleResolution": "node",
      "emitDeclarationOnly":true,
      "resolveJsonModule": true,
      "isolatedModules": true,
      "jsx": "react-jsx",
      "incremental": false,
      "sourceMap": false,
      "downlevelIteration": true,
      "paths": {
        "@/*": [
          "./src/*"
        ]
      },
      "strictNullChecks": true
    },
    "include": [
      "./src/**/*.ts",
      "./src/**/*.tsx",
    ],
    "exclude": [
      "node_modules",
    ]
  }
</file>

<file path="apps/uaito/next-env.d.ts">
/// <reference types="next" />
/// <reference types="next/image-types/global" />
/// <reference types="next/navigation-types/compat/navigation" />
/// <reference path="./.next/types/routes.d.ts" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.
</file>

<file path="apps/uaito/package.json">
{
  "name": "@uaito/site",
  "version": "1.0.0",
  "private": true,
  "description": "",
  "main": "index.js",
  "scripts": {
    "dev": "npx next dev -p 3005",
    "build": " next build",
    "test": "echo \"Error: no test specified\" && exit 1",
    "release": "sh release"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@headlessui/react": "^2.1.2",
    "@heroicons/react": "^2.1.5",
    "@octokit/rest": "^21.0.2",
    "@react-spring/web": "^9.7.4",
    "@react-three/drei": "^9.111.5",
    "@react-three/fiber": "^8.17.6",
    "@stablelib/hash": "^2.0.0",
    "@stablelib/sha512": "^2.0.0",
    "@stablelib/uuid": "^2.0.0",
    "@stripe/stripe-js": "^4.1.0",
    "@types/express": "^4.17.21",
    "@types/jsonwebtoken": "^9.0.6",
    "@types/rellax": "^1.7.7",
    "@uaito/sdk": "^0.4.1",
    "autoprefixer": "^10.4.19",
    "axios": "^1.7.2",
    "bcrypt": "^5.1.1",
    "cors": "^2.8.5",
    "custom-electron-titlebar": "^4.2.8",
    "dotenv": "^16.4.5",
    "electron-is-dev": "^1.2.0",
    "electron-react-titlebar": "^1.2.1",
    "express": "^4.19.2",
    "framer-motion": "^11.3.17",
    "fs-extra": "^11.2.0",
    "jsonwebtoken": "^9.0.2",
    "moment-timezone": "^0.5.45",
    "mongoose": "^8.5.1",
    "next": "15.5.3",
    "next-auth": "^4.24.11",
    "next-redux-wrapper": "^8.1.0",
    "nextjs-cors": "^2.2.0",
    "playwright": "^1.45.3",
    "puppeteer": "^23.2.1",
    "raw-body": "^3.0.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-icons": "^5.3.0",
    "react-markdown": "^9.0.1",
    "react-parallax-tilt": "^1.7.237",
    "react-redux": "^9.1.2",
    "react-router-dom": "^6.25.1",
    "react-scroll-parallax": "^3.4.5",
    "react-syntax-highlighter": "^15.5.0",
    "react-toastify": "^10.0.5",
    "recharts": "^2.12.7",
    "redis": "^4.7.0",
    "rellax": "^1.12.1",
    "scrolly-video": "^0.0.23",
    "sharp": "^0.33.5",
    "simple-git": "^3.25.0",
    "stripe": "^16.6.0",
    "swr": "^2.2.5",
    "three": "^0.168.0",
    "update-electron-app": "^3.0.0",
    "uuid": "^10.0.0",
    "voyageai": "^0.0.1-3"
  },
  "devDependencies": {
    "@babel/core": "^7.24.9",
    "@babel/plugin-proposal-class-properties": "^7.18.6",
    "@babel/plugin-transform-runtime": "^7.24.7",
    "@babel/preset-env": "^7.24.8",
    "@babel/preset-react": "^7.24.7",
    "@babel/preset-typescript": "^7.24.7",
    "@electron/notarize": "^2.3.2",
    "@reduxjs/toolkit": "^2.2.7",
    "@types/bcrypt": "^5.0.2",
    "@types/node": "^14.18.63",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@types/react-syntax-highlighter": "^15.5.13",
    "@types/uuid": "^10.0.0",
    "@types/webpack-hot-middleware": "^2.25.9",
    "babel-loader": "^9.1.3",
    "concurrently": "^8.2.0",
    "css-loader": "^7.1.2",
    "css-minimizer-webpack-plugin": "^7.0.0",
    "electron": "^27.1.2",
    "electron-builder": "^24.9.1",
    "electron-notarize": "^1.2.2",
    "eslint": "^8",
    "eslint-config-next": "14.2.5",
    "file-loader": "^6.2.0",
    "html-webpack-plugin": "^5.6.0",
    "mini-css-extract-plugin": "^2.9.0",
    "node-polyfill-webpack-plugin": "^4.0.0",
    "postcss": "^8.4.39",
    "postcss-loader": "^8.1.1",
    "prettier": "^3.3.3",
    "redux": "^5.0.1",
    "redux-immutable-state-invariant": "^2.1.0",
    "redux-thunk": "^3.1.0",
    "rimraf": "^3.0.2",
    "style-loader": "^4.0.0",
    "tailwindcss": "^3.4.6",
    "ts-loader": "^9.5.1",
    "typescript": "^5.8.4",
    "webpack": "^5.101.3",
    "webpack-cli": "^6.0.1",
    "webpack-dev-middleware": "^7.4.3",
    "webpack-hot-middleware": "^2.26.1"
  },
  "packageManager": "yarn@4.9.1+sha512.f95ce356460e05be48d66401c1ae64ef84d163dd689964962c6888a9810865e39097a5e9de748876c2e0bf89b232d583c33982773e9903ae7a76257270986538"
}
</file>

<file path="packages/sdk/src/llm/Anthropic.ts">
import SDK from '@anthropic-ai/sdk';
import { v4 } from 'uuid';
import { ImageBlockParam, MessageParam, TextBlockParam, ToolResultBlockParam, ToolUseBlockParam } from '@anthropic-ai/sdk/resources';
import { AnthropicOptions, MessageInput, Message, ToolUseBlock, ToolInputDelta, DeltaBlock, OnTool, UsageBlock, ErrorBlock, LLMProvider, BlockType, BaseLLMCache, ReadableStreamWithAsyncIterable } from "../types";
import { BaseLLM } from "./Base";
import { MessageArray } from '../utils';

type AnthropicConstructor = {
  options: AnthropicOptions,
  onTool?: OnTool
}

export class Anthropic extends BaseLLM<LLMProvider.Anthropic, AnthropicOptions> {
  public cache: BaseLLMCache = { toolInput: null, chunks: '',  tokens: { input: 0, output: 0 } }

  private onTool?: OnTool
  protected api: SDK;
  public inputs: MessageArray<MessageInput> = new MessageArray();

  constructor(
    { options }: AnthropicConstructor,
    onTool?: OnTool,
  ) {
    super(LLMProvider.Anthropic, options);
    this.api = new SDK({
      apiKey: options.apiKey,
      dangerouslyAllowBrowser: true
    })
    this.onTool = onTool;
  }

  get maxTokens() {
    return this.options.maxTokens ?? 8192
  }

  private fromInputToParam(model: MessageInput): MessageParam {
    const content: Array<TextBlockParam | ImageBlockParam | ToolUseBlockParam | ToolResultBlockParam>
      = model.content
        .filter((contentModel) =>
          contentModel.type !== "tool_delta" &&
          contentModel.type !== 'usage' &&
          contentModel.type !== "delta" &&
          contentModel.type !== "error"
        )
        .map((contentModel) => {
          if (contentModel.type === "text") {
            const textBlock: TextBlockParam = {
              type: 'text',
              text: contentModel.text
            }
            return textBlock
          } else if (contentModel.type === "image") {
            const imageBlock: ImageBlockParam = contentModel
            return imageBlock
          } else if (contentModel.type === "tool_use") {
            const toolUseBlock: ToolUseBlockParam = {
              type: 'tool_use',
              id: contentModel.id,
              input: contentModel.input,
              name: contentModel.name
            }
            return toolUseBlock
          }

          const toolResultBlock: ToolResultBlockParam = {
            is_error: contentModel.isError,
            tool_use_id: contentModel.tool_use_id,
            type: contentModel.type,
            content: contentModel.content!
              .map((content) => {
                if (content.type === "image") {
                  const imageBlock: ImageBlockParam = content
                  return imageBlock
                }
                if (content.type === "text") {
                  const textBlock: TextBlockParam = {
                    type: 'text',
                    text: content.text
                  }
                  return textBlock;
                }
                return content
              }) as any
          }
          return toolResultBlock
        })
    
        
    return {
      role: model.role,
      content
    } as MessageParam
  }

  private chunk(
    chunk: SDK.RawMessageStreamEvent
  ): Message | null {
    if (chunk.type === "content_block_start") {
      if (chunk.content_block.type === 'tool_use') {
        this.cache.chunks = null
        this.cache.toolInput = chunk.content_block
        this.cache.toolInput.input = ""
        const toolUseBlock: ToolUseBlock = chunk.content_block
        this.cache.toolInput = toolUseBlock;
        return {
          id: v4(),
          role: 'assistant',
          type: 'tool_use',
          content: [
            toolUseBlock
          ]
        }
      }
    } else if (chunk.type === "content_block_delta") {
      const delta = chunk.delta;
      if (delta.type === 'text_delta') {
        return {
          id: this.cache.chunks!,
          role: 'assistant',
          type: 'message',
          chunk: true,
          content: [
            {
              type: 'text',
              text: delta.text,
            }
          ]
        }
      } else if (delta.type === 'input_json_delta') {
        this.cache.chunks = null
        const toolInputBlock: ToolInputDelta = {
          type: 'tool_delta',
          partial: delta.partial_json
        }
        this.cache.toolInput = toolInputBlock;
        return {
          id: v4(),
          role: 'assistant',
          type: 'tool_delta',
          content: [toolInputBlock]
        }
      }
    } else if (chunk.type === "content_block_stop") {
      this.cache.chunks = null
      const isTool = this.cache.toolInput?.type === "tool_use";
      if (isTool) {
        const toolInput = this.cache.toolInput as SDK.ToolUseBlock;
        this.cache.toolInput = null
        return {
          id: v4(),
          role: 'assistant',
          type: 'tool_use',
          content: [toolInput]
        }
      }
    } else if (chunk.type === "message_delta") {
      this.cache.tokens.output = chunk.usage.output_tokens;
      this.cache.chunks = null;

      if (chunk.delta.stop_reason === "max_tokens") {
        const errorBlock: ErrorBlock = {
          type: 'error',
          message: `Exceeding the token limit, ${chunk.usage.output_tokens}`
        }
        return {
          id: v4(),
          role: 'assistant',
          type: 'error',
          content: [
            errorBlock
          ]
        }

      } else {
        const usageBlock: UsageBlock = {
          type: "usage",
          output: chunk.usage.output_tokens,
          input: this.cache.tokens.input
        }
        return {
          id: v4(),
          role: 'assistant',
          type: 'delta',
          content: [
            chunk.delta as DeltaBlock,
            usageBlock
          ]
        }
      }
    } else if (chunk.type === "message_start") {
      this.cache.chunks = chunk.message.id;
      this.cache.toolInput = null
      this.cache.tokens.input = chunk.message.usage.input_tokens;
      const usageBlock: UsageBlock = {
        type: "usage",
        output: 0,
        input: this.cache.tokens.input
      }
      return {
        id: v4(),
        role: 'assistant',
        type: 'usage',
        content: [
          usageBlock
        ]
      }
    }
    return null
  }

  get llmInputs() {
    return this.inputs
    .flatMap((input) => this.fromInputToParam(input))
    .filter((c) => {
      if (Array.isArray(c.content) && c.content.length === 0) {
        return false;
      }
      return true;
    })
    .flat()
  }

   async performTaskStream(
    prompt: string,
    chainOfThought: string,
    system: string,
  ): Promise<ReadableStreamWithAsyncIterable<Message>> {
    this.inputs = this.includeLastPrompt(prompt, chainOfThought, this.inputs);

    const params: SDK.MessageCreateParams = {
      max_tokens: this.maxTokens,
      system: system,
      messages:this.llmInputs,
      model: this.options.model,
      tools: this.options.tools
    };
    const apiHeaders: Record<string, string> = {}

    const options = { headers: apiHeaders, signal: this.options?.signal as any }

    const createStream = async () => {
      return this.retryApiCall(async() => {
          const stream = await this.api.messages.create(
            {
              ...params,
              stream: true
            },
            options
          )
          return stream.toReadableStream() as ReadableStreamWithAsyncIterable<SDK.RawMessageStreamEvent>
      });
    };

    const stream = await createStream();
    const transform = await this.transformStream<SDK.RawMessageStreamEvent, Message>(
      stream,
      this.chunk.bind(this)
    )

    const automodeStream = await this.transformAutoMode(
      transform,
      async () => {
        params.messages = this.llmInputs
        const stream =await createStream();
        return this.transformStream<SDK.RawMessageStreamEvent, Message>(
          stream, 
          this.chunk.bind(this)
        )
      },
      this.onTool?.bind(this)
    )
    

    return automodeStream
  }

   async performTaskNonStream(
    prompt: string,
    chainOfThought: string,
    system: string,
  ): Promise<Message> {
    const apiHeaders: Record<string, string> = {
      'anthropic-version': '2023-06-01',
      'anthropic-beta': 'max-tokens-3-5-sonnet-2024-07-15'
    }
    const apiOptions = { headers: apiHeaders, signal: this.options?.signal as any }
    this.inputs.push(...this.includeLastPrompt(prompt, chainOfThought, this.inputs))
    let sdkMessage: SDK.Messages.Message;
    while(true) {
      const params: SDK.MessageCreateParamsNonStreaming = {
        max_tokens: this.maxTokens,
        system: system,
        messages: this.inputs.map(this.fromInputToParam),
        model: this.options.model,
        // @ts-ignore
        tools: this.options.tools,
        stream: false
      };
      sdkMessage = await this.retryApiCall(() => this.api.messages.create(params, apiOptions));
      const message = {role: sdkMessage.role, content: sdkMessage.content};
      this.inputs.push(message)

      if (sdkMessage.stop_reason === "end_turn") break;
      if (sdkMessage.stop_reason === "tool_use") {
        const tool = sdkMessage.content.find(
          (content): content is SDK.ToolUseBlock => content.type === 'tool_use',
        );
        console.log(`[task messages]tool is ${tool?.name}`);
        if (tool && this.onTool) {
          await this.onTool.bind(this)(message, this.options.signal);
        } else {
          console.log(`[task messages] tool not found ${tool?.name}`);
        }
        // The next iteration will include any (tool) content appended in onTool if needed
      } 
    }
    return {
      id: sdkMessage.id,
      role: sdkMessage.role,
      type: "message",
      content: sdkMessage.content
    };
  }
}
</file>

<file path="apps/uaito/src/pages/api/[provider]/[agent]/messages.ts">
import type { NextApiRequest, NextApiResponse } from 'next';
import { AbortController } from 'abort-controller';
import NextCors from 'nextjs-cors';
import {SHA512} from '@stablelib/sha512';
import { Agent, AnthropicModels, AnthropicOptions, ErrorBlock, LLMProvider, Message, MessageArray, MessageInput, OpenAIModels, TextBlock, Tool } from '@uaito/sdk';
import { browseWebPageTool, createFileTool, createFolderTool, editAndApplyTool, executeCommandTool, readFileTool, tavilySearch } from '@/ai/tools';
import { findUserByEmail, IUser } from "@/db/models/User"
import { createUsage } from '@/db/models/Usage';
import { getSessionUser } from '@/utils/getSessionUser';
import db from '@/db';
import { ensureUserExists } from '../../auth/[...nextauth]';
import { AutomatedEngineer } from '@/ai/agents/AutomatedEngineer';
import { createChainOfThought } from '@/ai/prompts/AutomatedEngineer';
import { onTool as SystemOnTool } from '../../../../ai/agents/onTool';

const SEPARATOR = "<-[*0M0*]->"

function toProvider(p: string | string[] | undefined): LLMProvider {
  const s = Array.isArray(p) ? p[0] : p;
  switch (s) {
    case 'OpenAI':
      return LLMProvider.OpenAI;
    case 'Anthropic':
      return LLMProvider.Anthropic;
    case 'HuggingFaceONNX':
      return LLMProvider.HuggingFaceONNX;
    default:
      return LLMProvider.Anthropic;
  }
}

async function AutomatedEngineerTask(
  type: LLMProvider,
  res: NextApiResponse,
  currentUser: IUser,
  abortController: AbortController,
  inputs: MessageArray<MessageInput>,
  isGod: boolean,
  directory: string,
  prompt: string,
  tools?: Tool[]
):Promise<{hash: Uint8Array, stream:ReadableStream<Message>}> {
  const availableTools = tools && Array.isArray(tools) ? 
  tools: directory ? [
    createFolderTool,
    createFileTool,
    editAndApplyTool,
    readFileTool,
    browseWebPageTool,
    tavilySearch,
    executeCommandTool,
  ]: [
    browseWebPageTool,
    tavilySearch,
  ];
  const chainOfThought = createChainOfThought(availableTools);
  const activeTools = availableTools.map((tool) => {
    const {name, description, input_schema} = tool;
    return {name, description, input_schema}
  })
  const apiKey = type === LLMProvider.Anthropic ? process.env.ANTHROPIC_API_KEY :  process.env.OPENAI_API_KEY;
  const model = type === LLMProvider.Anthropic ? AnthropicModels['claude-4-sonnet'] : OpenAIModels["gpt-4o"];
  const options: AnthropicOptions = {
    apiKey: apiKey,
    model,
    signal: abortController.signal,
    maxTokens: process.env.MAX_TOKENS && !isGod ?parseInt(process.env.MAX_TOKENS): 8192,
    tools:activeTools
  };
  const hash = new SHA512();
  hash.update(
    Uint8Array.from(
      Buffer.from(
        JSON.stringify(options)
      )
    )
  )
  const hashId =  hash.digest();
  const threadId = Buffer.from(hashId).toString('hex')
  res.writeHead(200, {
    'Content-Type': 'text/plain',
    'Transfer-Encoding': 'chunked',
    'Cache-Control': 'no-cache, no-transform',
    'Connection': 'keep-alive',
    'X-Thread-Id': threadId
  });
  const agent = new AutomatedEngineer(
    type,
    options,
    function onTool(
      this: Agent<LLMProvider.Anthropic>,
      message: Message,
    )  {
        return SystemOnTool.bind(this)(
          currentUser.id,
          threadId,
          message,
          this.inputs, 
          abortController
        )
      },
    directory,
    inputs,
    chainOfThought
  );
  const { response } = await agent.performTask(prompt, '', chainOfThought, true);
  return {
    stream:response,
    hash:hashId
  }
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  await NextCors(req, res, {
    methods: ['GET', 'HEAD', 'PUT', 'PATCH', 'POST', 'DELETE', 'OPTIONS'],
    origin: '*',
    optionsSuccessStatus: 200,
  });
  res.setHeader("Access-Control-Expose-Headers","X-Thread-Id")
  if (req.method !== 'POST') {
    res.setHeader('Allow', 'POST');
    return res.status(405).end('Method Not Allowed');
  }
  await db.connect()
  const rawBody = req.body;
  const currentUser = await getSessionUser(req, res)
  if (!currentUser) {
    return res.status(403).end('Invalid session or auth token');
  }
  const abortController = new AbortController();
  res.on('close', () => {
    abortController.abort();
    console.log('Client disconnected, aborting stream');
  });
  const { provider } = req.query;
  const parsedBody = JSON.parse(rawBody.toString());

  try {
    const inputs = (parsedBody.inputs ?? []).map((input ) => {
      if (typeof input === "string") {
        return JSON.parse(input)
      }
      return input
    });
    const { prompt, directory, tools } = parsedBody;
    const gods = process.env.GODS ? process.env.GODS.split(",").map((e) => e.trim()): [];
    const email = currentUser.email
    const isGod = gods.includes(email);
    const safeInputs = new MessageArray<MessageInput>(inputs)


      if (!prompt) {
        throw new Error('No prompt provided');
      }
      const {stream, hash} = await AutomatedEngineerTask(
        toProvider(provider),
        res, 
        currentUser,
        abortController,
        safeInputs,
        isGod,
        directory,
        prompt,
        tools
      )
      const reader = stream.getReader();
      const threadId = Buffer.from(hash).toString('hex')
      await ensureUserExists(
        {
          email: email,
          name: currentUser.name
        }
      )
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        const usage = (value?.content?? []).find((content) => content.type === "usage");
        if (usage ) {
          const existingUser = await findUserByEmail(email);
          if (!existingUser) {
            throw new Error("Unexpected user not found")
          }
          await createUsage(
            existingUser,
            threadId,
            usage.input,
            usage.output
          )
        }
        const chunk = JSON.stringify(value);
        res.write(chunk.toString() +  SEPARATOR);
        if (value.type === "delta") {
          const deltaBlock = value.content.find((block) => block.type === "delta");
          if (deltaBlock) {
            const stopReason = deltaBlock.stop_reason;
            console.log("Stream ended:", stopReason);
            if (stopReason === "end_turn" || stopReason === "max_tokens") {
              break;
            }
          }
        }
      
    }
  } catch (error) {
    console.error("Error:", error);
    const errorBlock: ErrorBlock = {
      type: 'error',
      message: (error as Error).message
    };
    const chunk = Buffer.from(JSON.stringify(errorBlock))
    res.write(chunk.toString() +  SEPARATOR);
  } finally {
    res.end();
  }
}
</file>

<file path="packages/sdk/src/llm/Base.ts">
import type { AbortSignal } from 'abort-controller';
import type { 
  BaseLLMOptions, 
  Message,
  MessageInput,
  OnTool,
  ReadableStreamWithAsyncIterable,
  ToolUseBlock,
  ToolResultBlock,
  ErrorBlock,
  ToolInputDelta,
  BaseLLMCache
} from '../types';
import { Runner } from '../types';
import { v4 } from 'uuid';
import { MessageArray } from '../utils';

/**
 * Represents a function that transforms a chunk of data in a stream.
 * @template T The type of the input chunk.
 * @template M The type of the output message.
 * @param {T} chunk - The input chunk to be transformed.
 * @param {ReadableWritablePair<M, T>} stream - The stream to read from and write to.
 * @returns {Promise<M[]>} A promise that resolves to an array of transformed messages.
 */
export type TransformStreamFn<T, M> = (
  chunk: T,
) => M | null

/**
 * Abstract base class for Language Model implementations.
 * @template TYPE The type of the language model.
 * @template OPTIONS The type of options for the language model, extending BaseLLMOptions.
 * @extends {Runner}
 */
export abstract class BaseLLM<
  TYPE,
  OPTIONS extends BaseLLMOptions,
> extends Runner {
  /** An array of message inputs. */
  private MAX_RETRIES = 10;
  private RETRY_DELAY = 3000; // 3 seconds
  public abstract cache: BaseLLMCache
  public abstract inputs: MessageArray<MessageInput>
  public data: Record<string, unknown> = {}
  public log: (message: string) => void = console.log;

  async retryApiCall<T>(apiCall: () => Promise<T>): Promise<T> {
    let retries = 0;
    while (retries < this.MAX_RETRIES) {
        try {
            return await apiCall();
        } catch (error) {
            if (error instanceof Error && error.message.includes('APIConnectionError')) {
                retries++;
                console.log(`API call failed. Retrying in 3 seconds... (Attempt ${retries}/${this.MAX_RETRIES})`);
                await new Promise(resolve => setTimeout(resolve, this.RETRY_DELAY));
            } else {
                throw error; // Rethrow if it's not a connection error
            }
        }
    }
    throw new Error(`Max retries (${this.MAX_RETRIES}) reached. Unable to complete the API call.`);
}

/**
 * Perform a task using the LLM.
 * @param prompt - The user prompt.
 * @param stream - Whether to stream the response.
 * @returns A Promise resolving to either a ReadableStream of Messages or a single Message.
 */
performTask(
    prompt: string,
    chainOfThought: string,
    system: string,
    stream?: true
): Promise<{
    usage: { input: number, output: number },
    response: ReadableStream<Message> & AsyncIterable<Message>
}>;
performTask(
    prompt: string,
    chainOfThought: string,
    system: string,
    stream?: false
): Promise<{
    usage: { input: number, output: number },
    response: Message
}>;
async performTask(
    prompt: string,
    chainOfThought: string,
    system: string,
    stream?: boolean
): Promise<{
    usage: { input: number, output: number },
    response: Message | (ReadableStream<Message> & AsyncIterable<Message>)
}> {
    const response = stream === true ?
        await this.retryApiCall(() => this.performTaskStream(prompt, chainOfThought, system)) :
        await this.retryApiCall(() => this.performTaskNonStream(prompt, chainOfThought, system));

    return {
        usage: this.cache.tokens,
        response
    }
}

/**
 * Run a command safely, catching and handling any errors.
 * @param tool - The tool being used.
 * @param input - Array of input messages.
 * @param run - Function to run the command.
 */
async runSafeCommand(
    toolUse: ToolUseBlock,
    run: (agent: unknown) => Promise<void>
) {
    if (toolUse.type !== "tool_use") {
        throw new Error("Expected ToolUseBlock content inside tool_use type message")
    }
    try {
        await run(this);
    } catch (err) {
        const error = (err as Error);
        console.log(err);
        this.inputs.push({
            role: 'user',
            content: [
                {
                    name: toolUse.name,
                    type: 'tool_result',
                    tool_use_id: toolUse.id,
                    isError: true,
                    content: [{
                        type: 'text',
                        text: `An error occurred while running ${toolUse.name}: we got error -> ${error.message}`
                    }]

                }
            ]
        })
    }
}

  /**
   * Creates an instance of BaseLLM.
   * @param {TYPE} type - The type of the language model.
   * @param {OPTIONS} options - The options for the language model.
   */
  constructor(public readonly type: TYPE, protected options: OPTIONS) {
    super()
  }

   includeLastPrompt(prompt: string, chainOfThought: string, input: MessageArray<MessageInput>):MessageArray<MessageInput>  {
    const promptWithChainOfThought = `${prompt}\r\n\r\n${chainOfThought}`
    if (input.length<= 0) {
      return MessageArray.from(
        [
          { role: 'user', content: [{ type: 'text', text: promptWithChainOfThought }] }
        ]
      )
    }
    const last = input[input.length - 1];
    if (last && last.content.length > 0) {
      const found = last.content.find((c) => c.type === "text" && c.text === promptWithChainOfThought);
      if (found) {
          return input;
      } else {
          if (input[input.length - 1].role === 'user' && input[input.length - 1].content[0].type === 'text') {
              input[input.length - 1].content.push({ type: 'text', text: promptWithChainOfThought });
          } else {
              input.push({ role: 'user', content: [{ type: 'text', text: promptWithChainOfThought }] })
          }
          return input;
      }
  }
    return MessageArray.from(
      [
        ...input,
        { role: 'user', content: [{ type: 'text', text: promptWithChainOfThought }] }
      ]
    )
  }

  /**
   * Transforms an input stream using the provided transform function.
   * @template T The type of the input chunk.
   * @template S The type of the output stream, extending ReadableStream.
   * @param {S} input - The input stream to be transformed.
   * @param {TransformStreamFn<T, S>} transform - The function to transform each chunk.
   * @returns {Promise<ReadableStream<S>>} A promise that resolves to the transformed readable stream.
   */
  async transformAutoMode<AChunk extends Message> (
    input: ReadableStreamWithAsyncIterable<AChunk>,
    getNext: () => Promise<ReadableStreamWithAsyncIterable<AChunk>>,
    onTool?:OnTool
  ) {
    const stream = new ReadableStream({
       start :async (controller) => {
        let reader: ReadableStreamDefaultReader<AChunk> = input.getReader();
        
        while (true) {
          const readerResult = await reader.read();
          if (readerResult.done) break;

          try {
            if (!readerResult.value) {
              continue;
            }
            const tChunk:AChunk =  readerResult.value;

            this.log(`tChunk: ${tChunk.type} ${JSON.stringify(tChunk)}`);

            if (tChunk.type === "error" || 
              tChunk.type === "usage" || 
              tChunk.type === "delta" || 
              tChunk.type === "tool_delta" || 
              tChunk.type === "message"
            ) {
              controller.enqueue(tChunk)
            } else if (tChunk.type === "tool_use") {
              this.inputs.push(tChunk);
              controller.enqueue({
                id: tChunk.id,
                role: tChunk.role,
                content: tChunk.content,
                type: 'tool_use'
              })
              if (onTool && tChunk.content[0].type === "tool_use" ) {
                const toolUse = tChunk.content[0] as ToolUseBlock;
                const cacheEntry = (this.cache.toolInput ?? {}) as ToolInputDelta;
                const partial = cacheEntry?.partial || (cacheEntry as unknown as { input: string }).input;
                if (partial) {
                  toolUse.input = {}  
                } else {
                  
                  toolUse.input = typeof partial === "string" ? JSON.parse(partial === "" ? "{}" : partial) : partial;
                }
                await onTool.bind(this)(tChunk, this.options.signal);
                const lastOutput = this.inputs[this.inputs.length - 1];
                if (lastOutput.role !== "user" || lastOutput.content[0].type !== 'tool_result') {
                    throw new Error("Expected to have a user reply with the tool response");
                }
  
                if (lastOutput.content[0].type === 'tool_result') {
                  lastOutput.content[0] = {
                    ...lastOutput.content[0],
                    name: (tChunk.content[0] as ToolUseBlock).name
                  } as ToolResultBlock;
                }

                controller.enqueue({
                  id: v4(),
                  role:'user',
                  content: lastOutput.content,
                  type: 'tool_result'
                });

              
                const newStream = await getNext.bind(this)();
                const oldReader = reader;
                reader = newStream.getReader()
                oldReader.releaseLock()
                
              }
            } 
          } catch (err: unknown) {
            const errorBlock: ErrorBlock = {
              type: "error",
              message: (err as Error).message
            }
            controller.enqueue({
              id: v4(),
              role:'assistant',
              type: 'error',
              content: [errorBlock]
            } as Message)
          }
        }
        await this.release(reader, controller)
      }
    })
    return stream as ReadableStreamWithAsyncIterable<AChunk>
  }

  private async release<AChunk extends Message>(
    reader: ReadableStreamDefaultReader<AChunk>, 
    controller: ReadableStreamDefaultController<Message>
  ) {
    try {
      reader.releaseLock()
      controller.close()
    } catch (err) {
      console.log("error can be ignore but ", err)
    }
  }

  /**
   * Transforms the given stream from an AI provider into a Uaito Stream
   * This also keeps track of the received messages
   * @param input 
   * @param transform 
   * @returns 
   */
  async transformStream<AChunk, BChunk extends Message>(
    input: ReadableStreamWithAsyncIterable<AChunk>,
    transform: TransformStreamFn<unknown, BChunk>,
  ): Promise<ReadableStreamWithAsyncIterable<BChunk>> {

    const reader = input.getReader();

    function emit(
      controller: ReadableStreamDefaultController<BChunk>,
      message: BChunk
    ) {
      controller.enqueue(message);
    }

    const stream = new ReadableStream({
      async start(controller) {
        while(true) {
          const s = await reader.read();
          if (s.done) break;
          
          if (!s.value) {
            continue;
          }
          const message = s.value instanceof Uint8Array ? transform(
            JSON.parse(
              Buffer.from(
                s.value as unknown as Uint8Array
              ).toString()
            )
          ) : transform(s.value);


          if (message !== null) {
            //Message pre-processing, cache and tools
            const isErrorMessage = message.type === "error";
            const isDeltaMessage = message.type === "delta";
            const isToolDeltaMessage = message.type === "tool_delta";
            const isToolUseMessage = message.type === "tool_use";
            const isChunkMessage = message.type === "message";
            const isUsageMessage = message.type === "usage";

            if (isChunkMessage || isErrorMessage || isToolDeltaMessage || isToolUseMessage || isUsageMessage) {
              emit(controller, message);
            } else if (isDeltaMessage) {
              for (const content of message.content) {
                if (content.type === "usage") {
                  const usageMessage = {
                    id: v4(),
                    role:'assistant',
                    type: 'usage',
                    content: [content]
                  } as BChunk
                  emit(controller, usageMessage)
                } else if (content.type === "delta") {
                  if (content.stop_reason === "max_tokens" || content.stop_reason === "end_turn") {
                    emit(controller, message)
                  } 
                }
              }
            } 
          } 
        }
        reader.releaseLock()
      }
    })
    return stream as ReadableStream<BChunk> & AsyncIterable<BChunk>
  }
}
</file>

<file path="packages/sdk/src/llm/HuggingFaceONNX.ts">
import { v4 } from "uuid";

import type {
  BaseLLMCache,
  OnTool,
  ReadableStreamWithAsyncIterable,
  Message,
  HuggingFaceONNXOptions,
  MessageInput,
  MessageType,
  ToolUseBlock,
  ToolResultBlock,
  TextBlock,
} from "../types";
import { LLMProvider } from "../types";

import type {
  Message as HMessage,
  PreTrainedTokenizer,
  PreTrainedModel,
} from "@huggingface/transformers";
import { AutoTokenizer, AutoModelForCausalLM, TextStreamer, AutoConfig } from "@huggingface/transformers";



import { BaseLLM } from "./Base";
import type { TensorDataType } from "./huggingface/types";
import { MessageArray } from "../utils";
import { extractPythonicCalls, mapArgsToNamedParams, parsePythonicCall } from "./huggingface/utils";

// Removed unused IM_START_TAG to satisfy linter and avoid confusion
const IM_END_TAG = '<|im_end|>';

const modelCache = new Map<string, PreTrainedModel>();
const tokenizerCache = new Map<string, PreTrainedTokenizer>();

type HuggingFaceMessage = HMessage & {
  type?: MessageType,
  id?: string
}



export class HuggingFaceONNX extends BaseLLM<LLMProvider.HuggingFaceONNX, HuggingFaceONNXOptions> {
  public cache: BaseLLMCache = { toolInput: null, chunks: '', tokens: { input: 0, output: 0 } }
  public loadProgress: number = 0;
  public inputs: MessageArray<MessageInput> = new MessageArray();

  private tokenizer!: PreTrainedTokenizer;
  private model!: PreTrainedModel;
  private currentMessageId: string | null = null;

  constructor(
    { options }: { options: HuggingFaceONNXOptions },
    public onTool?: OnTool
  ) {
    super(LLMProvider.HuggingFaceONNX, options);
    this.data.progress = 0;
  }

  async load() {
    this.log(`Loading model: ${this.options.model}`);
    const modelId = this.options.model;
    
    if (tokenizerCache.has(modelId)) {
      this.tokenizer ??= tokenizerCache.get(modelId)!;
    } else {
      this.tokenizer ??= await AutoTokenizer.from_pretrained(modelId);
      tokenizerCache.set(modelId, this.tokenizer);
    }

    this.log(`Tokenizer loaded for ${modelId}`);
    if (modelCache.has(modelId)) {
      this.model ??= modelCache.get(modelId)!;
    } else {
      const config =  await AutoConfig.from_pretrained(modelId);

      this.model ??= await AutoModelForCausalLM.from_pretrained(modelId, {
        device: this.options.device ?? "webgpu",
        dtype: this.options.dtype ?? "auto",
        config: {
          ...config,
           'transformers.js_config':{
            ...config["transformers.js_config"],
            kv_cache_dtype:{
              "q4f16": "float16" as const,
              "fp16": "float16" as const
            } as any
           }
        } ,
        progress_callback: (info: Record<string, unknown>) => {
          if (info.status === "progress") {
            const progress = parseInt(info.progress as string, 10);
            this.data.progress = progress;
            if (this.options.onProgress) {
              this.options.onProgress(progress);
            }
          } else {
            this.log(`Model loading status: ${info.status}`);
          }
        },
      });
      modelCache.set(modelId, this.model);
    }
    this.log(`Model loaded: ${modelId}`);
  }

  private fromInputToParam(message: MessageInput): HuggingFaceMessage {
    const { content } = message;
    let role = message.role;


    const textContent = content
      .filter((c): c is TextBlock => c.type === "text")
      .map((c) => c.text)
      .join("\n\n");

    const toolUseContent = content
      .filter((c): c is ToolUseBlock => c.type === "tool_use")
      .map((toolUse) =>
        JSON.stringify({
          id: toolUse.id,
          name: toolUse.name,
          parameters: toolUse.input,
          type: 'tool_use'
        })
      )
      .join("\n");

    const toolResultContent = content
      .filter((c): c is ToolResultBlock => c.type === "tool_result")
      .map((toolResult) => {

        const textContent = (toolResult.content ?? [])
          .filter((c): c is TextBlock => c.type === "text")
          .map((c) => c.text)
          .join("\n\n");

        return JSON.stringify({
          tool_use_id: toolResult.tool_use_id,
          name: toolResult.name,
          content: textContent,
          is_error: toolResult.isError ?? false,
        });
      })
      .join("\n");

      
    if (toolUseContent) {
      return {
        id: message.id,
        role: 'assistant',
        content: toolUseContent,
      };
      
    }

    if (toolResultContent) role = 'tool';

    const finalContent = [textContent, toolUseContent, toolResultContent].filter(Boolean).join('\n\n');
    return {
      role: role,
      content: finalContent,
    };
  }

  private getTensorData() {
    const currentInputs =  Array.from([
      ...this.inputs
    ])
      .filter((m) => m.content.length >  0 && m.content[0].type !== 'tool_use' && m.role !== 'tool')
      .map(this.fromInputToParam);

      debugger;
    return this.tokenizer.apply_chat_template(currentInputs, {
      add_generation_prompt: true,
      return_dict: true,
      tools: this.options.tools,
    }) as TensorDataType;
  }

  private state: {
    buffer: string,
    capturingToolCall: boolean
  } = {
      buffer: '',
      capturingToolCall: false
    }

  private chunk(chunk: string): Message | null {
    this.state.buffer += chunk;
    this.currentMessageId ??= v4();

    if (!this.state.capturingToolCall) {
      const startIndex = this.state.buffer.indexOf('<|tool_call_start|>') !== -1? 
        this.state.buffer.indexOf('<|tool_call_start|>') : 
        this.state.buffer.indexOf('<tool_call>');
      
      if (startIndex !== -1) {
        if (this.state.buffer.indexOf('<|tool_call_start|>') !== -1) {
          this.state.buffer = this.state.buffer.substring(startIndex + '<|tool_call_start|>'.length);
        } else if (this.state.buffer.indexOf('<tool_call>') !== -1) {
          this.state.buffer = this.state.buffer.substring(startIndex + '<tool_call>'.length);
        }
        this.state.capturingToolCall = true;
        const textPart = this.state.buffer.substring(0, startIndex);
        if (textPart) {
          return {
            id: this.currentMessageId,
            role: 'assistant',
            type: 'message',
            chunk: true,
            content: [{ type: 'text', text: textPart }]
          };
        }
      }
    }

    if (this.state.capturingToolCall) {
      const endIndex = this.state.buffer.indexOf('<|tool_call_end|>') !== -1? 
        this.state.buffer.indexOf('<|tool_call_end|>') : 
        this.state.buffer.indexOf( '</tool_call>');

      if (endIndex !== -1) {
        const toolCallContent = this.state.buffer.substring(0, endIndex);
        this.log(`Detected tool call content: "${toolCallContent}"`);
        if (this.state.buffer.indexOf('<|tool_call_end|>') !== -1) {
          this.state.buffer = this.state.buffer.substring(endIndex + '<|tool_call_end|>'.length);
        } else if (this.state.buffer.indexOf('</tool_call>') !== -1) {
          this.state.buffer = this.state.buffer.substring(endIndex + '</tool_call>'.length);
        }
        this.state.capturingToolCall = false;

        const toolCalls = extractPythonicCalls(toolCallContent);


        const toolUseBlocks: ToolUseBlock[] = toolCalls.flatMap(call => {
          this.log(`Parsing tool call: "${call}"`);
          const parsed = parsePythonicCall(call);
          if (!parsed) return [];
          
          const { name, positionalArgs, keywordArgs } = parsed;
          const toolSchema = this.options.tools?.find((t) => t.name === name);
          const paramNames = toolSchema ? Object.keys(toolSchema.input_schema.properties) : [];
          const input = mapArgsToNamedParams(paramNames, positionalArgs, keywordArgs);

          return {
            id: v4(),
            name,
            input,
            type: 'tool_use'
          };
        });

        if (toolUseBlocks.length > 0) {
          this.log(`Emitting ${toolUseBlocks.length} tool_use blocks.`);
          this.currentMessageId = null;
          // For simplicity in this refactor, we'll wrap all tool calls in a single message.
          // The `BaseLLM`'s `transformAutoMode` will handle dispatching them.
          return {
            id: v4(),
            role: 'assistant',
            type: 'tool_use',
            content: toolUseBlocks
          };
        }
      }
    }
    
    // If no tool call markers are processed, treat the buffer as text
    if (!this.state.capturingToolCall && (chunk.indexOf('<|tool_call_start|>') === -1 && chunk.indexOf('<tool_call>') === -1)) {
      const textToEmit = this.state.buffer;
      this.state.buffer = '';
      if (textToEmit) {
        return {
          id: this.currentMessageId,
          role: 'assistant',
          type: 'message',
          chunk: true,
          content: [{ type: 'text', text: textToEmit }]
        };
      }
    }

    return null;
  }
  
  async createStream(input: TensorDataType): Promise<ReadableStreamWithAsyncIterable<string>> {
    this.log("createStream called.");
    this.state.buffer = '';
    this.state.capturingToolCall = false;

    let __past_key_values: any =null;

    const stream = new ReadableStream<string>({
      start: async (controller) => {
        this.log("ReadableStream started for model generation.");

        try {
          const streamer = new TextStreamer(this.tokenizer, {
            skip_prompt: true,
            skip_special_tokens: false,
            callback_function: (value: string) => {
              controller.enqueue(value
                .replace(IM_END_TAG, "")
                .replace(' <|endoftext|>', "</think>")
              );
            },
          });
      
      
          const { sequences, past_key_values } = await (this.model as any).generate({
           ...input,
           past_key_values:__past_key_values,
            do_sample: false,
            generation_config:{
              output_attentions: true,
              max_new_tokens: this.options.maxTokens ?? 4096,
            },
            streamer,
            return_dict_in_generate: true,
          });

          const response = this.tokenizer
          .batch_decode(sequences.slice(null, [input.input_ids.dims[1], null]), {
            skip_special_tokens: false,
          })[0]
          .replace(/<\|im_end\|>$/, "");
          this.currentMessageId= null


         this.inputs.push({
          id: v4(),
          role: 'assistant',
          type: 'message',
          content: [{ type: 'text', text: response }]
      })


          __past_key_values = past_key_values;
         
          controller.close();
        } catch (e) {
          this.log(`Model generation error: ${e}`);
          controller.error(e);
        }
      },
    });

    return stream as ReadableStreamWithAsyncIterable<string>;
  }

  private addDefaultItems(prompt: string, system: string, chainOfThought: string) {
    if (this.inputs.length === 0 && system !== '') {
      //Internal message
      const systemPrompt: Message = {
        id: v4(),
        role: "system",
        type: "message",
        content: [{
          text: system,
          type: "text"
        }]
      }
      this.inputs.push(systemPrompt as MessageInput);
    }
    this.inputs =  MessageArray.from(
      [
        ...this.inputs,
        { role: 'user', content: [{ type: 'text', text: `${prompt}${chainOfThought !== '' ? `\r\n\r\n${chainOfThought}` : ''}` }] }
      ]
    )
  }

  async performTaskStream(prompt: string, chainOfThought: string, system: string): Promise<ReadableStreamWithAsyncIterable<Message>> {
    this.log("Starting performTaskStream");
    await this.load();

    this.addDefaultItems(prompt, system, chainOfThought);
    debugger;
    const tensor = this.getTensorData();
    this.log(`Tensor created. Shape: ${tensor.input_ids.dims}`);

    const rawStream = await this.createStream(tensor);
    const transformedStream = await this.transformStream<string, Message>(
      rawStream,
      this.chunk.bind(this)
    );
    const automodeStream = await this.transformAutoMode(
      transformedStream,
      async () => {
        const nextTensor = this.getTensorData();
        const nextRawStream = await this.createStream(nextTensor);
        return this.transformStream<string, Message>(
          nextRawStream,
          this.chunk.bind(this)
        );
      },
      this.onTool?.bind(this)
    );

    return automodeStream;
  }

  performTaskNonStream(_prompt: string, _chainOfThought: string, _system: string): Promise<Message> {
    throw new Error("Method not implemented.");
  }

}
</file>

<file path="packages/sdk/src/agents/index.ts">
import { MessageInput, BaseLLMOptions, AnthropicOptions, Message, OnTool, AgentTypeToOptions, LLMProvider, Tool, OpenAIOptions, AgentTypeToClass, HuggingFaceONNXOptions, ToolUseBlock } from "../types";
import { BaseLLM } from "../llm/Base";
import { MessageArray } from "../utils";

export const LOG_ANSI_RED = "\u001B[31m";
export const LOG_ANSI_GREEN = "\u001B[32m";
export const LOG_ANSI_GRAY = "\u001B[90m";
export const LOG_ANSI_BLUE = "\u001B[34m";
export const LOG_ANSI_RESET = "\u001B[0m";
export const LOG_ANSI_YELLOW = "\u001B[33m";


/**
 * base class for AI agents.
 */
export class Agent<T extends LLMProvider> {
    private MAX_RETRIES = 10;
    private RETRY_DELAY = 3000; // 3 seconds
    /** The LLM client used by the agent. */
    public client!: AgentTypeToClass[T];

    /**
     * Log a message with the agent's color and name.
     * @param message - The message to log.
     */
    log(message: string) {
        console.log(`${this.color}[${this.name}] ${message}${LOG_ANSI_RESET}`);
    }

    protected name: string;
    /**
     * Create a new Agent instance.
     * @param type - The type of LLM provider.
     * @param options - Configuration options for the LLM.
     */
    constructor(
        public type: LLMProvider,
        protected options: AgentTypeToOptions[typeof type],
        protected onTool?: OnTool,
        public inputs: MessageArray<MessageInput> = new MessageArray(),
        public tools: Tool[] = [],
        protected color: string = LOG_ANSI_BLUE,
        name?: string
    ) {
        this.name = name ?? this.type.toString();
     }

    get data() {
        return this.client?.data ?? {};
    }

    async load() {
        await this.getClient();
        if ("load" in this.client) {
            await this.client.load();
        }
    }

    clear() {
        this.client.inputs.length = 0;
    }

    private async getClient(): Promise<BaseLLM<any, BaseLLMOptions>> {
        if (this.type === LLMProvider.Anthropic) {
            const Anthropic = (await import("../llm/Anthropic")).Anthropic;
            this.client ??= new Anthropic({
                options: this.options as AnthropicOptions
            },
                this.onTool,
            ) as AgentTypeToClass[T];
        } else if (this.type === LLMProvider.OpenAI) {
            const OpenAI = (await import("../llm/Openai")).OpenAI;
            this.client ??= new OpenAI({
                options: this.options as OpenAIOptions
            },
                this.onTool
            ) as AgentTypeToClass[T];
        } else if (this.type === LLMProvider.HuggingFaceONNX) {
            const HuggingFace = (await import("../llm/HuggingFaceONNX")).HuggingFaceONNX;
            this.client ??= new HuggingFace({
                options: this.options as HuggingFaceONNXOptions
            },
                this.onTool
            ) as AgentTypeToClass[T];
        } else {
            throw new Error("not implemented")
        }
        this.client.log = this.log.bind(this);
        return this.client;
    }

    async retryApiCall<T>(apiCall: () => Promise<T>): Promise<T> {
        let retries = 0;
        while (retries < this.MAX_RETRIES) {
            try {
                return await apiCall();
            } catch (error) {
                if (error instanceof Error && error.message.includes('APIConnectionError')) {
                    retries++;
                    this.log(`API call failed. Retrying in 3 seconds... (Attempt ${retries}/${this.MAX_RETRIES})`);
                    await new Promise(resolve => setTimeout(resolve, this.RETRY_DELAY));
                } else {
                    throw error; // Rethrow if it's not a connection error
                }
            }
        }
        throw new Error(`Max retries (${this.MAX_RETRIES}) reached. Unable to complete the API call.`);
    }

    /**
     * Perform a task using the LLM.
     * @param prompt - The user prompt.
     * @param stream - Whether to stream the response.
     * @returns A Promise resolving to either a ReadableStream of Messages or a single Message.
     */
    performTask(
        prompt: string,
        chainOfThought: string,
        system: string,
        stream?: true
    ): Promise<{
        usage: { input: number, output: number },
        response: ReadableStream<Message> & AsyncIterable<Message>
    }>;
    performTask(
        prompt: string,
        chainOfThought: string,
        system: string,
        stream?: false
    ): Promise<{
        usage: { input: number, output: number },
        response: Message
    }>;
    async performTask(
        prompt: string,
        chainOfThought: string,
        system: string,
        stream: boolean = true
    ): Promise<{
        usage: { input: number, output: number },
        response: Message | (ReadableStream<Message> & AsyncIterable<Message>)
    }> {
        const client = await this.getClient();
        const response = stream === true ?
            await this.retryApiCall(() => client.performTaskStream(prompt, chainOfThought, system)) :
            await this.retryApiCall(() => client.performTaskNonStream(prompt, chainOfThought, system));

        return {
            usage: client.cache.tokens,
            response
        }
    }

    /**
     * Run a command safely, catching and handling any errors.
     * @param tool - The tool being used.
     * @param input - Array of input messages.
     * @param run - Function to run the command.
     */
    async runSafeCommand(
        toolUse: ToolUseBlock,
        run: (agent: any) => Promise<void>
    ) {
        if (toolUse.type !== "tool_use") {
            throw new Error("Expected ToolUseBlock content inside tool_use type message")
        }
        try {
            await run(this);
        } catch (err) {
            const error = (err as Error);
            console.log(err);
            this.client.inputs.push({
                role: 'user',
                content: [
                    {
                        name: toolUse.name,
                        type: 'tool_result',
                        tool_use_id: toolUse.id,
                        isError: true,
                        content: [{
                            type: 'text',
                            text: `An error occurred while running ${toolUse.name}: we got error -> ${error.message}`
                        }]

                    }
                ]
            })
        }
    }
}
</file>

<file path="packages/sdk/src/types.ts">
import { AbortSignal } from 'abort-controller';

import type { Anthropic } from "./llm/Anthropic";
import type { OpenAI } from "./llm/Openai";
import type { Agent } from "./agents";
import { HuggingFaceONNX } from './llm/HuggingFaceONNX';

export enum HuggingFaceONNXModels {
  Llama32_3B = "onnx-community/Llama-3.2-3B-Instruct-onnx-web",
  Llama32_1B = "onnx-community/Llama-3.2-1B-Instruct-q4f16",
  Test2 = "onnx-community/DeepSeek-R1-Distill-Qwen-1.5B-ONNX",
  Test = "elribonazo/demo",
  LMF2_350M = "onnx-community/LFM2-350M-ONNX",
  LMF2_700M = "onnx-community/LFM2-700M-ONNX",
  LMF2_1_2B = "onnx-community/LFM2-1.2B-ONNX",
  QWEN_1 = "onnx-community/Qwen3-0.6B-ONNX",
  QWEN_2 = "onnx-community/Qwen3-1.7B-ONNX"
}

export enum AnthropicModels {
  'claude-3-5-sonnet' = 'claude-3-5-sonnet-20240620',
  'claude-3-haiku' = 'claude-3-haiku-20240307',
  'claude-3-opus' = 'claude-3-opus-20240229',
  'claude-4-sonnet' = 'claude-sonnet-4-20250514'
}

export enum OpenAIModels {
  'gpt-4o' = 'gpt-4o',
}

export type ArrayElementType<T> = T extends (infer U)[] ? U : never;
export type AnthropicOptions = { apiKey?: string } & BaseLLMOptions;
export type OpenAIOptions = { apiKey?: string } & BaseLLMOptions;
export type HuggingFaceONNXOptions =  BaseLLMOptions & {
  model: HuggingFaceONNXModels,
  dtype: DType,
  device: "auto" | "webgpu" | "cpu" | "cuda" | "gpu" | "wasm" | "dml" | "webnn" | "webnn-npu" | "webnn-gpu" | "webnn-cpu" | Record<string, "auto" | "webgpu" | "cpu" | "cuda" | "gpu" | "wasm"  | "webnn-cpu"> | undefined
};
export type Tool = {
  id?: number;
  name: string;
  description: string;
  input_schema: {
    type: "object";
    properties: Record<string, {
      type: string;
      description: string;
      default?: unknown;
    }>;
    required?: string[];
  };
  code?: string;
  enabled?: boolean;
  isCollapsed?: boolean;
};
export type DType = "auto" | "fp32" | "fp16" | "q8" | "int8" | "uint8" | "q4" | "bnb4" | "q4f16" | Record<string, "auto" | "fp32" | "fp16" | "q8" | "int8" | "uint8" | "q4" | "bnb4" | "q4f16"> | undefined

export type BaseLLMCache = {
    toolInput: BlockType | null,
    chunks: string | null,
    tokens: {
      input: number,
      output: number
    }
  }

export enum LLMProvider {
  OpenAI = 'OpenAI',
  Anthropic = 'Anthropic',
  HuggingFaceONNX = 'HuggingFaceONNX'
}

export type OnTool<T extends LLMProvider = LLMProvider> = (
  this: Agent<T>,
  message: Message, 
  signal?: AbortSignal
) => Promise<void>

export interface SearchReplaceBlock {
  search: string;
  replace: string;
}

export type AgentTypeToOptions = {
    [LLMProvider.Anthropic]: AnthropicOptions;
    [LLMProvider.OpenAI]: OpenAIOptions;
    [LLMProvider.HuggingFaceONNX]: HuggingFaceONNXOptions;
    [name: string]: unknown
  };

export type AgentTypeToClass = {
  [LLMProvider.Anthropic]: Anthropic;
  [LLMProvider.OpenAI]: OpenAI;
  [LLMProvider.HuggingFaceONNX]: HuggingFaceONNX;
  [name: string]: unknown
};

export type BinConfig<P extends LLMProvider> = {
  provider: P,
  options: AgentTypeToOptions[P],
  tools?: Tool[],
  createSystemPrompt?: (tools: Tool[]) => string,
  chainOfThought?: string,
  onTool?: OnTool,
}

export type USAGE = {
  input_tokens: number;
  output_tokens: number;
}

export type MessageType =
  'message' |
  ToolInputDelta['type'] |
  ToolUseBlock['type'] |
  ToolResultBlock['type'] |
  DeltaBlock['type'] |
  UsageBlock['type'] | 
  ErrorBlock['type']


export type ImageBlock = {
  source: {
    data: string;
    media_type: 'image/jpeg' | 'image/png' | 'image/gif' | 'image/webp';
    type: 'base64';
  };
  type: 'image';
}

export type TextBlock = {
  text: string;
  type: 'text';
}


export type ToolUseBlock = {
  id: string;
  input: unknown;
  name: string;
  type: 'tool_use';
}

export type ToolInputDelta = {
  id?:string,
  name?:string,
  partial:string,
  type: 'tool_delta';
}

export type ToolResultBlock = {
  tool_use_id: string;
  name: string,
  type: 'tool_result';
  content?: MessageContent[];
  isError?: boolean;
}

export type ToolBlock = ToolInputDelta | ToolUseBlock  | ToolResultBlock ;
export type Role = 'assistant' | 'user' | 'system' | 'tool';

export type BlockType = ErrorBlock | TextBlock | ToolBlock | ImageBlock | DeltaBlock | UsageBlock;
export type Message = {
  id: string,
  type: MessageType,
  content: BlockType[],
  chunk?: boolean,
  role: Role
}

export type DeltaBlock =   {
  type:'delta',
  stop_reason: 'end_turn' | 'max_tokens' | 'stop_sequence' | 'tool_use' | null;

  stop_sequence: string | null;

}

export type UsageBlock = {
  type: 'usage',
  input?: number,
  output?: number
}

export type ErrorBlock = {
  type:'error',
  message: string
}

export type MessageContent = ArrayElementType<Message['content']>

export type MessageInput = {
  id?: string,
  type?: MessageType,
  role: Role,
  content: MessageContent[]
}

export type BaseLLMOptions = {
    model: string,
    tools?: Tool[]
    maxTokens?: number,
    signal?: AbortSignal,
    directory?: string,
    onProgress?: (progress: number) => void,
}

export type ReadableStreamWithAsyncIterable<T> = ReadableStream<T> & AsyncIterable<T>;

export abstract class Runner {
   abstract performTaskStream(
    userPrompt: string,
    chainOfThought: string,
    system: string,
): Promise<ReadableStreamWithAsyncIterable<Message>>;

 abstract performTaskNonStream(
    userPrompt: string,
    chainOfThought: string,
    system: string,
): Promise<Message>;
}
</file>

<file path="packages/sdk/package.json">
{
  "name": "@uaito/sdk",
  "version": "0.4.2",
  "description": "UAITO Typescript SDK",
  "main": "build/index.js",
  "module": "build/index.mjs",
  "types": "build/index.d.ts",
  "files": [
    "build/**/*"
  ],
  "scripts": {
    "build": "rm -rf build && sh build.sh",
    "types:default": "npx tsc",
    "test": "echo \"Error: no test specified\" && exit 1",
    "prepublishOnly": "npm run build"
  },
  "author": "elribonazo <elribonazo@uaito.io>",
  "license": "ISC",
  "repository": {
    "type": "git",
    "url": "https://github.com/uaito/sdk.git"
  },
  "keywords": [
    "uaito",
    "sdk",
    "typescript"
  ],
  "publishConfig": {
    "access": "public"
  },
  "devDependencies": {
    "@esbuild-plugins/node-resolve": "^0.2.2",
    "@types/lodash": "^4.17.20",
    "@types/node": "^14.18.63",
    "@types/yargs": "^17.0.33",
    "dotenv": "^16.4.7",
    "esbuild-node-externals": "^1.16.0",
    "esbuild-plugin-glob": "^2.2.3",
    "ts-node": "^10.9.2",
    "typescript": "^5.5.4"
  },
  "dependencies": {
    "@anthropic-ai/sdk": "^0.36.3",
    "@huggingface/transformers": "^3.7.2",
    "@monaco-editor/react": "^4.7.0",
    "abort-controller": "^3.0.0",
    "idb": "^8.0.3",
    "lodash": "^4.17.21",
    "openai": "^4.83.0",
    "uuid": "^10.0.0",
    "yargs": "^18.0.0"
  },
  "resolutions": {
    "@llamaindex/openai": "0.4.19"
  },
  "bin": {
    "uaito": "build/cli.js"
  },
  "packageManager": "yarn@4.9.1+sha512.f95ce356460e05be48d66401c1ae64ef84d163dd689964962c6888a9810865e39097a5e9de748876c2e0bf89b232d583c33982773e9903ae7a76257270986538"
}
</file>

<file path="apps/uaito/Dockerfile">
# Stage 1: Build the monorepo
FROM node:20
WORKDIR /app

# Set environment variables
ARG MAX_TOKENS
ENV MAX_TOKENS=${MAX_TOKENS}
ARG ANTHROPIC_API_KEY
ENV ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
ARG OPENAI_API_KEY
ENV OPENAI_API_KEY=${OPENAI_API_KEY}
ARG GCLIENT_ID
ENV GCLIENT_ID=${GCLIENT_ID}
ARG GCLIENT_SECTET
ENV GCLIENT_SECTET=${GCLIENT_SECTET}
ARG MONGODB_URL
ENV MONGODB_URL=${MONGODB_URL}
ARG GODS
ENV GODS=${GODS}
ARG GITHUB_OWNER
ENV GITHUB_OWNER=${GITHUB_OWNER}
ARG GITHUB_REPO
ENV GITHUB_REPO=${GITHUB_REPO}
ARG GITHUB_PAT
ENV GITHUB_PAT=${GITHUB_PAT}
ARG ENDPOINT
ENV ENDPOINT=${ENDPOINT}

# Enable corepack and set correct yarn version
RUN corepack enable
RUN corepack prepare yarn@4.9.1 --activate

# Copy root package.json and yarn.lock for workspace setup
COPY package.json yarn.lock ./

# Copy all workspace package.json files for proper dependency resolution
COPY packages/sdk/package.json ./packages/sdk/
COPY apps/uaito/package.json ./apps/uaito/
COPY apps/electron/package.json ./apps/electron/
COPY playground/nextjs/package.json ./playground/nextjs/
COPY playground/node/package.json ./playground/node/

# Install all workspace dependencies
RUN yarn install --immutable

# Copy the entire monorepo source code
COPY . .

# Reinstall to ensure workspace linking after copying source
RUN yarn install --immutable

# Build the SDK package first (required by the site)
RUN yarn workspace @uaito/sdk build

# Build the site
RUN yarn workspace @uaito/site build

WORKDIR /app/apps/uaito

EXPOSE 3000

CMD GODS=${GODS} MONGODB_URL=${MONGODB_URL} GCLIENT_ID=${GCLIENT_ID} GCLIENT_SECTET=${GCLIENT_SECTET} ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY} NEXT_PUBLIC_MAX_TOKENS=${NEXT_PUBLIC_MAX_TOKENS} MAX_TOKENS=${MAX_TOKENS} OPENAI_API_KEY=${OPENAI_API_KEY} npx next start
</file>

</files>
